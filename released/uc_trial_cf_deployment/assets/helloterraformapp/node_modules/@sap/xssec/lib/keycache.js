'use strict';

const LRU = require('lru-cache');
const nodeRSA = require('node-rsa');
const validUrl = require('valid-url');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
var debug = require('debug');
var debugTrace = debug('xssec:keycache');
var debugError = debug('xssec:keycache');

const constants = require('./constants');
const requests = require('./requests');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

exports.KeyCache = KeyCache;

function KeyCache(cacheSize, cacheEntryExpirationTimeInMinutes, callUaaToReadTokenKeys, tokenKeyPath) {
    debugTrace('Initializing KeyCache with parameters cacheSize (' + cacheSize
            + '), cacheEntryExpirationTimeInMinutes ('
            + cacheEntryExpirationTimeInMinutes + '), callUaaToReadTokenKeys ('
            + callUaaToReadTokenKeys + '), tokenKeyPath (' + tokenKeyPath
            + ').');

    // validate input
    if (!cacheSize || cacheSize < 5) {
        var error = new Error(
                'Parameter cacheSize invalid. To initialize the KeyCache, specify the mandatory numeric parameter cacheSize (>= 5).');
        throw error;
    }

    if (cacheEntryExpirationTimeInMinutes === undefined) {
        debugTrace('Parameter cacheEntryExpirationTimeInMinutes undefined. Setting default ('+constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES+') for this optional parameter from configuration.');
        cacheEntryExpirationTimeInMinutes = constants.KEYCACHE_DEFAULT_CACHE_ENTRY_EXPIRATION_TIME_IN_MINUTES;
    } else if (cacheEntryExpirationTimeInMinutes < 0) {
        var error = new Error(
                'Parameter cacheEntryExpirationTimeInMinutes invalid. To initialize the KeyCache, you can specify the optional numeric parameter cacheEntryExpirationTimeInMinutes (>= 0).');
        throw error;
    }

    if (callUaaToReadTokenKeys === undefined) {
        debugTrace('Parameter callUaaToReadTokenKeys undefined. Setting default (true) for this optional boolean parameter from configuration.');
        this.callUaaToReadTokenKeys = true;
    } else if (!((callUaaToReadTokenKeys === true) || (callUaaToReadTokenKeys === false))) {
        var error = new Error(
                'Parameter callUaaToReadTokenKeys invalid. To initialize the KeyCache, you can specify the optional boolean parameter callUaaToReadTokenKeys (true, false).');
        throw error;
    } else {
        this.callUaaToReadTokenKeys = callUaaToReadTokenKeys;
    }

    if (tokenKeyPath === undefined) {
        debugTrace('Parameter tokenKeyPath undefined. Setting default ("'+constants.KEYCACHE_DEFAULT_TOKENKEY_PATH+'") for this optional string parameter from configuration.');
        this.tokenKeyPath = constants.KEYCACHE_DEFAULT_TOKENKEY_PATH;
    } else {
        this.tokenKeyPath = tokenKeyPath;
    }

    this.lruCache = new LRU({
        max : cacheSize,
        maxAge : cacheEntryExpirationTimeInMinutes * 60000
    });
}

KeyCache.prototype.addKey = function addKey(keyId, key) {
    if ((keyId === null) || (keyId === undefined)) {
        var error = new Error('Parameter keyId null or undefined. To add a key to the KeyCache with function KeyCache.addKey, you need to specify parameter keyId.');
        throw error;
    }
    if ((key === null) || (key === undefined)) {
        var error = new Error('Parameter key null or undefined. To add a key to the KeyCache with function KeyCache.addKey, you need to specify parameter key.');
        throw error;
    }
    debugTrace('Adding key to cache. keyID: "' + keyId + '", key: "' + key + '".');
    this.lruCache.set(keyId, key);
};

function createPublicKeyFromJWKS(json) {
    if (json.kty !== "RSA") {
        throw new Error("KTY '" + json.kty + "' not supported");
    }

    const modulus = Buffer.from(json.n, 'base64');
    const exponent = Buffer.from(json.e, 'base64');

    const pubKey = new nodeRSA().importKey({ n: modulus, e: exponent }, 'components-public');

    return pubKey.exportKey('pkcs8-public-pem');
}

KeyCache.prototype.getWellKnownFromOIDC = function(serviceUrl, attrib, cb) {
    const attributes = attrib || { disableCache: false };
    const cacheKey = serviceUrl + ".well_known.";

    var tmpResult = attributes.disableCache === true ? null : this.lruCache.get(cacheKey);
    if(tmpResult) {
        cb(null, tmpResult);
    } else {
        var self = this;

        requests.requestOpenIDConfiguration(serviceUrl, attributes, function(err, result) {
            if(err) {
                return cb(err);
            }

            if(attributes.disableCache !== true) {
                self.addKey(cacheKey, result);
            }            
            cb(null, result);
        });
    }
}

KeyCache.prototype.getKeyOIDC = function(serviceUrl, keyId, zone_id, attrib, cb) {
    const attributes = attrib || { disableCache: false };
    const self = this;

    this.getWellKnownFromOIDC(serviceUrl, attributes, function(err, result) {
        if(err) {
            return cb(err);
        }

        let tokenUrl = result.jwks_uri;

        if(attributes.disableCache !== true) {
            let tmpResult = self.lruCache.get(zone_id + tokenUrl + keyId);
            if(tmpResult) {
                //found in Cache
                return cb(null, tmpResult);
            }
        }

        requests.fetchOIDCKey(tokenUrl, zone_id, attributes, function(err, result) {
            if(err) {
                return cb(err);
            }

            let found = null;
            //add all Keys to cache
            for(var i=0;i<result.keys.length;++i) {
                var key = result.keys[i];
                try {
                    const pem = createPublicKeyFromJWKS(key);
                    if(attributes.disableCache !== true) {
                        self.addKey(zone_id + tokenUrl + key.kid, pem);
                    }
                    if(key.kid === keyId) {
                        found = pem;
                    }
                } catch(e) {
                    debugError(e);
                }
            }

            const cacheKey = zone_id + tokenUrl + keyId;
            const tmpResult = attributes.disableCache === true ? found : self.lruCache.get(cacheKey);
            if(tmpResult) {
                cb(null, tmpResult);
            } else {
                cb(new Error("Verfication Key not found"));
            }
        });
    });
}

KeyCache.prototype.getKey = function getKey(tokenKeyUrl, keyId, zid, attrib, cb) {
    var self = this;
    const attributes = attrib || { disableCache: false };

    if ((tokenKeyUrl === null) || (tokenKeyUrl === undefined)) {
        var error = new Error('Parameter tokenKeyUrl null or undefined. To enable the KeyCache reading keys from the UAA which are yet unavailable in the cache, you need to specify parameter tokenKeyUrl as a valid https URL.');
        return cb(error);
    }
    if (validUrl.isHttpsUri(tokenKeyUrl) === undefined) {
        var error = new Error('Parameter tokenKeyUrl is not a valid https URL. To enable the KeyCache reading keys from the UAA which are yet unavailable in the cache, you need to specify parameter tokenKeyUrl as a valid https URL.');
        return cb(error);
    }
    if ((keyId === null) || (keyId === undefined)) {
        var error = new Error('Parameter keyId null or undefined. To read a key from the KeyCache with function KeyCache.getKey, you need to specify parameter keyId.');
        return cb(error);
    }

    var cacheKey = tokenKeyUrl + keyId;
    debugTrace('Looking for key "' + cacheKey + '" in cache.');
    // Check whether keyid is in cache
    var tmpResult = attributes.disableCache === true ? null : this.lruCache.get(cacheKey);
    if (tmpResult) {
        debugTrace('Key with keyID: "' + keyId + '" found in cache. Returning key "' + tmpResult + '".');
        return cb(null, tmpResult);
    } else if (this.callUaaToReadTokenKeys === false) {
        // no cache hit, but configuration says not to try to obtain key from UAA
        var error = new Error('Key "' + cacheKey + '" not found in cache. Configuration says not to query UAA.');
        return cb(error);
    } else {
        debugTrace('Key "' + cacheKey + '" not found in cache. Querying keys from UAA via URL "' + tokenKeyUrl + '" and zid: "' + zid + '".');

        return requests.fetchKeyFromXSUAA(tokenKeyUrl, zid, attributes, function(err, json) {
            if(err) {
                debugError(`An error occurred when reading the token keys from ${tokenKeyUrl}: ${err.message}${err.stack}`);
                err.tokenKeys = {
                    statuscode: err.response && err.response.statusCode ? err.response.statusCode : null,
                    body: err.response && err.response.body ? err.response.body : null
                };
                return cb(err);
            }

            debugTrace("Number of KeyIDs returned from XSUAA", json.keys.length);
            let found = null;
            for (var i = 0; i < json.keys.length; i++) {
                // Note: The following code removes line
                // breaks before adding the key to the cache

                const id = tokenKeyUrl + json.keys[i].kid;
                const pem = json.keys[i].value.replace(/(\r\n|\n|\r)/gm, '');

                if(id === cacheKey) {
                    found = pem;
                }

                if(attributes.disableCache !== true) {
                    self.addKey(id, pem);
                }
            }

            var tmpResult = attributes.disableCache === true ? found : self.lruCache.get(cacheKey);
            if (tmpResult) {
                debugTrace('Key "' + cacheKey + '" found in cache. Returning key "' + tmpResult + '".');
                return cb(null, tmpResult);
            } else {
                var error = new Error('Obtained token keys from UAA, but key with requested keyID "' + cacheKey + '" still not found in cache.');

                //for better logging functionality
                error.tokenKeys = {
                    statuscode: 200,
                    body: json
                };
                error.statuscode = 500;
                return cb(error);
            }
        });
    }
};
