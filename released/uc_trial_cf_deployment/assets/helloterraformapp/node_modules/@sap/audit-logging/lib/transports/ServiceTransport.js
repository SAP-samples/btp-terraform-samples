'use strict';

var assert = require('assert');
var debug = require('debug')('audit/transport');
var fetchBase = require('node-fetch');
var fetch = require('fetch-retry')(fetchBase);
var util = require('util');
var http = require('http');
var https = require('https');
var xssec = require('@sap/xssec');
var requests = xssec.requests;

function ServiceTransport(credentials, options, securityContext) {
  checkCredentials(credentials);
  this.subdomain = null;
  this.credentials = credentials;
  this.serviceURL = credentials.url + options.url;
  var requestAgentOptions = credentials.requestAgentOptions || {};
  debug('HTTP(S) Agent Options: %o', requestAgentOptions);
  var requestAgentClass = (this.serviceURL.startsWith('https')) ? https.Agent : http.Agent;
  this.requestAgent = new requestAgentClass(requestAgentOptions);
  this.appInfo = process.env.VCAP_APPLICATION ? JSON.parse(process.env.VCAP_APPLICATION) : {};
  this.securityContext = securityContext;
}

ServiceTransport.prototype.log = function (message, callback) {
  var url = this.serviceURL + message._endpoint;
  var body = message._content;

  this._doRequest(url, 'POST', body, callback);
};

ServiceTransport.prototype.updateConfigurationChange = function (id, state, callback) {
  this._updateState('configuration-changes/', id, state, callback);
};

ServiceTransport.prototype.updateDataModification = function (id, state, callback) {
  this._updateState('data-modifications/', id, state, callback);
};

ServiceTransport.prototype._updateState = function (subPath, id, state, callback) {
  var url = this.serviceURL + subPath + id;
  var body = {
    success: state
  };

  this._doRequest(url, 'POST', body, callback);
};

ServiceTransport.prototype._doRequest = function (url, method, data, callback) {
  var headers = {
    'XS_AUDIT_APP': this.appInfo['application_name'],
    'XS_AUDIT_SPACE': this.appInfo['space_name'],
    'XS_AUDIT_ORG': this.appInfo['organization_name']
  };

  debug('Auditlog request: %s %s\n headers: %j\n body: %j',
    method, url, headers, data);

  getAuthHeader.call(this, (err, header) => {
    if (err) {
      return callback(err);
    }
    headers['Content-Type'] = 'application/json';
    headers['Authorization'] = header;
    var statusCode = null;

    const options = {
      method: method,
      retryDelay: 3000,
      retryOn: function (attempt, error, res) {
        // retry on any network error, or 429 or 5xx status codes
        var status = (res) ? res.status : NaN;
        if ((error !== null || status === 429 || status >= 500) && attempt < 5) {
          debug('Auditlog retry: attempt %d\n error "%s"\n status %d',
            attempt, error && error.message, status);
          return true;
        }
        return false;
      },
      headers: headers,
      body: JSON.stringify(data),
      agent: this.requestAgent
    };


    fetch(url, options).then(function (res) {
      debug('Auditlog response: status %s', res.status);
      statusCode = res.status;
      return res.text();
    }).then(function (body) {
      try {
        body = JSON.parse(body);
      } catch (e) {
        body = null;
      }
      debug('Auditlog response: body %j', body);

      if (statusCode < 200 || statusCode >= 300) {
        var message = util.format('%s request to %s completed with status %d', method, url, statusCode);
        if (body) {
          var responseErr = body.error || body.errors || body;
          message += ': ' + JSON.stringify(responseErr);
        }

        return callback(new Error(message));
      }

      // body is undefined when response's status is 204 No content
      callback(null, body && body.id);
    }).catch(function (err) {
      debug(err);
      return callback(err);
    });
  });
};

function getAuthHeader(callback) {
  if (this.credentials.user && this.credentials.password && this.credentials.url) {
    debug('Basic authentication: %s, %s, %s', this.credentials.user, this.credentials.password, this.credentials.url);
    return callback(null, 'Basic ' + Buffer.from(this.credentials.user + ':' + this.credentials.password).toString('base64'));
  }
  else if (this.securityContext && this.securityContext.getGrantType() !== 'client_credentials') {
    const userToken = this.securityContext.getTokenInfo().getTokenValue();
    debug('User token exchange: %s, %s', this.securityContext.getGrantType(), userToken);
    requests.requestUserToken(userToken, this.credentials.uaa, null, null, this.subdomain, null, (err, token) => {
      if (err) {
        return callback(err);
      }
      return callback(null, 'Bearer ' + token);
    });
  }
  else if (this.credentials.uaa && this.credentials.uaa.clientid
  && (this.credentials.uaa.clientsecret || (this.credentials.uaa.key && this.credentials.uaa.certificate))
  && this.credentials.uaa.url) {
    requests.requestClientCredentialsToken(this.subdomain, this.credentials.uaa, null, null, (err, token) => {
      if (err) {
        return callback(err);
      }
      return callback(null, 'Bearer ' + token);
    });
  }
  else {
    return callback('No applicable authorization header method found.', null);
  }
}

function checkCredentials(credentials) {
  assert(credentials, 'credentials should be provided!');
  assert(
    (credentials.user && credentials.password && credentials.url)
    || (credentials.url && credentials.uaa && credentials.uaa.clientid
    && (credentials.uaa.clientsecret || (credentials.uaa.key && credentials.uaa.certificate))
    && credentials.uaa.url),
    'credentials are missing information!');
}

module.exports = ServiceTransport;
