'use strict';
const keycache = require('./keycache');

const constants = require('./constants');
const url = require('url');

var debug = require('debug');
var debugTrace = debug('xssec:verificationkey');

//keyCache is now configureable using the config object
var keyCache = null;

function VerificationKey(config, type, attributes) {
    var tokenInfo = null;
    var loadKeyError = null;
    this.getCallback = function(token) {
        tokenInfo = token;
        if(type === "IAS") {
            return this.loadKeyOIDC.bind(this);            
        } else {
            return this.loadKeyXSUAA.bind(this);            
        }
    }

    this.getLoadKeyError = function() {
        return loadKeyError;
    }

    this.getType = function() {
        return type;
    }

    function cleanUp(pem) {
        if(!pem) {
            return null;
        }
        //the old ccl based jwt verification library was able to read malformed PEM formatted input.
        //but with the jsonwebtoken module we need to clean up some PEM errors before using it...
        if(pem.indexOf("-----BEGIN PUBLIC KEY-----\n") === -1) {
            pem = pem.replace("-----BEGIN PUBLIC KEY-----", "-----BEGIN PUBLIC KEY-----\n");
        }
        if(pem.indexOf("\n-----END PUBLIC KEY-----") === -1) {
            pem = pem.replace("-----END PUBLIC KEY-----", "\n-----END PUBLIC KEY-----");
        }
        return pem;
    }

    function validateJku(jkuUrl, uaaDomain) {
        if (!uaaDomain) {
            return 'Service is not properly configured in \'VCAP_SERVICES\', attribute \'uaadomain\' is missing. Use legacy-token-key.';
        }

        var tokenKeyUrl = url.parse(jkuUrl);
        if (tokenKeyUrl.hostname.substring(tokenKeyUrl.hostname.indexOf(uaaDomain), tokenKeyUrl.hostname.length) !== uaaDomain) {
            return 'JKU of the JWT token (' + jkuUrl + ') does not match with the uaa domain (' + uaaDomain + '). Use legacy-token-key.';
        }
    }

    function getKeyCache() {
        if(!keyCache) {
            keyCache = new keycache.KeyCache(config.keyCache.cacheSize, config.keyCache.expirationTime);
        }

        return keyCache;
    } 

    this.loadKeyOIDC = function(accessToken, cb) {
        if (!accessToken.kid) {
            return cb(new Error("No key identifier found in token"));
        }

        let keyCache = getKeyCache();

        var zone_id = tokenInfo.getPayload().zone_uuid || "";

        //try to get a key from KeyCache
        keyCache.getKeyOIDC(tokenInfo.getIssuer(), accessToken.kid, zone_id, attributes, function(err, key) {
            if (err) {
                debugTrace('\n' + err);
                return cb(err);
            } else {
                return cb(null, key);
            }
        });
    }

    this.loadKeyXSUAA = function(accessToken, cb) {
        var zid = tokenInfo.getPayload().zid;                
        if (!accessToken.kid || accessToken.kid == 'legacy-token-key' || !accessToken.jku) {
            return cb(null, cleanUp(config.verificationkey));
        }

        var errorString = validateJku(accessToken.jku, config.uaadomain);

        if(errorString) {
            debugTrace('\n' + errorString);
            loadKeyError = new Error(errorString);
            return cb(null, cleanUp(config.verificationkey));
        }

        let keyCache = getKeyCache();

        //try to get a key from KeyCache
        keyCache.getKey(accessToken.jku, accessToken.kid, zid, attributes, function(err, key) {
            if (err) {
                //store the 
                loadKeyError = err;
                debugTrace('\n' + err);
                return cb(null, cleanUp(config.verificationkey));
            } else {
                return cb(null, cleanUp(key));
            }
        });
    }
};

module.exports = VerificationKey;
