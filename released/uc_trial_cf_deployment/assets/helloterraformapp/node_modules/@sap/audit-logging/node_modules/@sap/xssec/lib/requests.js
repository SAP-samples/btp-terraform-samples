'use strict';

const constants = require('./constants');
const axios = require('axios');
const url = require('url');
const https = require('https');

const errors = require('./errors');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
const debug = require('debug');
const debugTrace = debug('xssec:requests');
const debugError = debug('xssec:requests');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

const X_ZONE_ID_HEADER_NAME = "x-zid";
const CORRELATIONID_HEADER = "x-vcap-request-id";

const DEFAULT_TIMEOUT = 2000;
const DEFAULT_USER_TOKEN_TIMEOUT = 10 * 1000;

async function _requestToNetworkAXIOS(fnc, options, cb) {
    debugTrace(fnc + '::HTTP Call with %O', options);

    const axios_options = {
        maxRedirects: 0, //no followRedirect
        headers: options.headers,
        url: options.url,
        method: options.method,
        timeout: options.timeout || DEFAULT_TIMEOUT
    };

    if(options.form) {
        axios_options.data = new url.URLSearchParams(options.form).toString();
    }

    if(options.https) {
        axios_options.httpsAgent = new https.Agent({
            cert: options.https.certificate,
            key: options.https.key
        });
    }

    try {
        const result = await axios(axios_options);
        const json = result.data;
        if(options._responseToken) {
            cb(null, json[options._responseToken], json);
        } else {
            cb(null, json.id_token || json.access_token || json, json);
        }        
    } catch (e) {
        return cb(e);
    }
}

let _requestToNetwork = _requestToNetworkAXIOS;

function validateParameters(serviceCredentials, cb) {
    // input validation
    if (!serviceCredentials) {
        return new Error('Parameter serviceCredentials is missing but mandatory.');
    }
    if (!serviceCredentials.clientid) {
        //client_secret will be checked later (only if really needed)
        return new Error('Invalid service credentials: Missing clientid.');
    }
    if (!serviceCredentials.url) {
        return new Error('Invalid service credentials: Missing url.');
    }
    if (!cb || typeof cb !== 'function') {
        return new Error('No callback function provided.');
    }
}

function buildSubdomain(serviceCredentials, subdomain) {
    var urlWithCorrectSubdomain = serviceCredentials.url;
    if (subdomain) {
        var tokenSubdomain = subdomain;
        var tokenRequestSubdomain = null;
        var uaaUrl = url.parse(serviceCredentials.url);
        if (uaaUrl.hostname.indexOf('.') === -1) {
            tokenRequestSubdomain = null;
        } else {
            tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
        }
        
        if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
            urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);          
        }

        if (serviceCredentials.certificate) {
            urlWithCorrectSubdomain = urlWithCorrectSubdomain.replace(".authentication.", ".authentication.cert.")
        }        
    } else {
        if (serviceCredentials.certificate) {
            urlWithCorrectSubdomain = serviceCredentials.certurl;
        }
    }

    return urlWithCorrectSubdomain;
}

function appendAdditonalAttributes(options, additionalAttributes) {
    if (additionalAttributes !== null) {
        var authorities = JSON.stringify({"az_attr": additionalAttributes});
        options.form.authorities = authorities;
    }
}

function DefaultHeaders(zoneId, serviceCredentials) {
    var ret = {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': constants.USER_AGENT
    };

    if (zoneId) {
        ret[X_ZONE_ID_HEADER_NAME] = zoneId;
    }

    return ret;
}

function buildOptions(serviceCredentials, additionalAttributes, url, grantType, zoneId, attributes) {
    // jwt bearer flow
    const options = {
        method: 'POST',
        url: url + '/oauth/token',
        headers: DefaultHeaders(zoneId, serviceCredentials),
        form: {
            grant_type: grantType,
            response_type: 'token',
            client_id: serviceCredentials.clientid
        },
        timeout: attributes.timeout
    };

    if (serviceCredentials.certificate) {
        options.https = {
            key: serviceCredentials.key,
            certificate: serviceCredentials.certificate
        }
    } else {
        //make sure we have a client_secret set here
        if (!serviceCredentials.clientsecret) {
            throw new Error('Invalid config: Missing clientsecret.');
        }

        options.form.client_secret = serviceCredentials.clientsecret;
    }

    appendAdditonalAttributes(options, additionalAttributes);

    if(attributes.correlationId) {
        options.headers[CORRELATIONID_HEADER] = attributes.correlationId;
    }

    if(attributes.scopes) {
        options.form.scope = attributes.scopes;
    }

    if(attributes.username) {
        options.form.username = attributes.username;
        options.form.password = attributes.password;
    }

    return options;
}

module.exports.requestOpenIDConfiguration = function (serviceCredentialsUrl, attributes, cb) {
    var options = {
        method: 'GET',
        followRedirect: false,
        timeout: DEFAULT_TIMEOUT,
        url: serviceCredentialsUrl + '/.well-known/openid-configuration',
        headers: {
            'Accept': 'application/json',
            'User-Agent': constants.USER_AGENT
        }
    };

    if(attributes) {
        if(attributes.correlationId) {
            options.headers[CORRELATIONID_HEADER] = attributes.correlationId;
        }
    }

    return _requestToNetwork(".well-known", options, cb);
}

module.exports.fetchOIDCKey = function (serviceCredentialsUrl, zone_id, attributes, cb) {
    var options = {
        method: 'GET',
        url: serviceCredentialsUrl,
        followRedirect: false,
        timeout: DEFAULT_TIMEOUT,
        headers: {
            'Accept': 'application/json',
            'User-Agent': constants.USER_AGENT
        }
    };

    if (zone_id) {
        options.headers['x-zone_uuid'] = zone_id;
    }

    if(attributes) {
        if(attributes.correlationId) {
            options.headers[CORRELATIONID_HEADER] = attributes.correlationId;
        }
    }

    return _requestToNetwork(".oidc-jkws", options, cb);
}

function getServiceCredentials(config) {
    if(config.credentials) {
        return config.credentials;
    }
    
    return config;
}

function getAttributes(config, defaultTimeout, maxTimeout) {
    let timeout = config.timeout || defaultTimeout;
    if(timeout > maxTimeout) {
        timeout = maxTimeout;
    } else if(timeout < DEFAULT_TIMEOUT) {
        timeout = DEFAULT_TIMEOUT;
    }
    
    if(config.credentials) {               
        return {
            scopes: config.scopes,
            correlationId: config.correlationId,
            timeout: timeout,
            username: config.username,
            password: config.password
        };
    }

    return {
        timeout: timeout
    };
}

module.exports.requestUserToken = function (appToken, config, additionalAttributes, scopes, subdomain, zoneId, cb) {
    //make it backward-compatible (where zoneId is not provided at all)
    if (typeof zoneId === 'function') {
        cb = zoneId;
        zoneId = null;
    }

    const serviceCredentials = getServiceCredentials(config);
    const attributes = getAttributes(config, DEFAULT_USER_TOKEN_TIMEOUT, 10*1000);

    var error = validateParameters(serviceCredentials, cb);
    if (error) {
        error.statuscode = 500;
        return cb(error, null);
    }

    const urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    try {
        // jwt bearer flow
        var options = buildOptions(serviceCredentials,
            additionalAttributes,
            urlWithCorrectSubdomain,
            'urn:ietf:params:oauth:grant-type:jwt-bearer',
            zoneId,
            attributes);

        //add Assertion
        options.form.assertion = appToken;

        if (scopes !== null) {
            options.form.scope = scopes;
        }

        return _requestToNetwork("requestUserToken", options, cb);
    } catch (e) {
        //the verification of the serviceCredentials fails
        e.statuscode = 500;
        return cb(e);
    }
}

module.exports.requestPasswordUserToken = function (subdomain, config, additionalAttributes, cb) {
    const serviceCredentials = getServiceCredentials(config);
    const attributes = getAttributes(config, DEFAULT_USER_TOKEN_TIMEOUT, 10*1000);

    // input validation
    const error = validateParameters(serviceCredentials, cb);
    if (error) {
        error.statuscode = 500;
        return cb(error, null);
    }

    // adapt subdomain in service url, if necessary
    const urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    try {
        const options = buildOptions(serviceCredentials,
            additionalAttributes,
            urlWithCorrectSubdomain,
            'password',
            null,
            attributes);

            appendAdditonalAttributes(options, additionalAttributes);

            options._responseToken = 'access_token';
        return _requestToNetwork("requestPasswordUserToken", options, cb);
    } catch (e) {
        //the verification of the serviceCredentials fails
        e.statuscode = 500;
        return cb(e);
    }
};

module.exports.requestClientCredentialsToken = function (subdomain, config, additionalAttributes, zoneId, cb) {
    //make it backward-compatible (where zoneId is not provided at all)
    if (typeof zoneId === 'function') {
        cb = zoneId;
        zoneId = null;
    }

    const serviceCredentials = getServiceCredentials(config);
    const attributes = getAttributes(config, DEFAULT_TIMEOUT, 5*1000);

    // input validation
    const error = validateParameters(serviceCredentials, cb);
    if (error) {
        error.statuscode = 500;
        return cb(error, null);
    }

    // adapt subdomain in service url, if necessary
    const urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    try {
        const options = buildOptions(serviceCredentials,
            additionalAttributes,
            urlWithCorrectSubdomain,
            'client_credentials',
            zoneId,
            attributes);

            appendAdditonalAttributes(options, additionalAttributes);
        return _requestToNetwork("requestClientCredentialsToken", options, cb);
    } catch (e) {
        //the verification of the serviceCredentials fails
        e.statuscode = 500;
        return cb(e);
    }
};

module.exports.fetchKeyFromXSUAA = async function (tokenKeyUrl, zid, attributes, cb) {
    const options = {
        headers: {
            "User-Agent": constants.USER_AGENT
        },
        method: "GET",
        url: tokenKeyUrl,
        followRedirect: false,
        timeout: DEFAULT_TIMEOUT
    };

    if(attributes) {
        if(attributes.correlationId) {
            options.headers[CORRELATIONID_HEADER] = attributes.correlationId;
        }
    }

    _requestToNetwork("fetchKeyFromXSUAA", options, cb);
}

module.exports.__patchNetwork = new function () {
    var oldrequestToXSUAA = _requestToNetwork;

    this.patch = function (fnc) {
        if (typeof fnc === 'function') {
            debugTrace("patch XSUAA communication to another function");
            _requestToNetwork = fnc;
        } else {
            if (_requestToNetwork !== oldrequestToXSUAA) {
                debugTrace("patch XSUAA communication to original function");
                _requestToNetwork = oldrequestToXSUAA;
            }
        }
    }
}
