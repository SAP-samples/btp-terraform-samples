'use strict';
const util = require('util');

const debug = require('debug');
const debugTrace = debug('xssec:validators');
const debugError = debug('xssec:validators');

const jwt = require('jsonwebtoken');

const TokenInfo = require('./tokeninfo');
const TokenExchanger = require('./tokenexchanger');

const requests = require('./requests');

const url = require('url');

const DOT = ".";

const ValidationResults = new function () {
    function Result(suc, desc) {
        var state = suc;
        var description = desc || "";

        this.isValid = function () {
            return suc === true;
        }

        this.isErroneous = function () {
            return suc === false;
        }

        this.getErrorDescription = function () {
            return description;
        }
    };

    this.createValid = function () {
        return new Result(true);
    }

    this.createInvalid = function (description) {
        return new Result(false, description)
    }
};

function JwtAudienceValidator(clientId) {
    var clientIds = [];
    var foreignMode = false;

    this.configureTrustedClientId = function (clientId) {
        if (clientId) {
            clientIds.push(clientId);
        }

        debugTrace("configured JwtAudienceValidator with clientId", clientId);
        return this;
    }

    this.validateToken = function (audiencesFromToken, scopesFromToken, cid) {
        foreignMode = false;
        var allowedAudiences = extractAudiencesFromToken(audiencesFromToken, scopesFromToken || [], cid);
        if (validateSameClientId(cid) === true || validateAudienceOfXsuaaBrokerClone(allowedAudiences) === true || validateDefault(allowedAudiences) === true) {
            return ValidationResults.createValid();
        }

        return ValidationResults.createInvalid("Jwt token with audience: " + util.inspect(allowedAudiences) + " is not issued for these clientIds: " + util.inspect(clientIds) + ".");
    }

    this.isForeignMode = function () {
        return foreignMode;
    }

    function validateSameClientId(cidFromToken) {
        if (!cidFromToken || !clientId) {
            return false;
        }

        return cidFromToken.trim() === clientId.trim();
    }

    //iterate over all configured clientIds and return true of the cb returns true
    function forEachClientId(cb) {
        for (var i = 0; i < clientIds.length; ++i) {
            if (cb(clientIds[i]) === true) {
                return true;
            }
        }

        return null;
    }

    function validateDefault(allowedAudiences) {
        return forEachClientId(function (configuredClientId) {
            if (allowedAudiences.includes(configuredClientId)) {
                return true;
            }
        });
    }

    function validateAudienceOfXsuaaBrokerClone(allowedAudiences) {
        var ret = forEachClientId(function (configuredClientId) {
            if (configuredClientId.includes("!b")) { //isBrokerClientId
                for (var i = 0; i < allowedAudiences.length; ++i) {
                    var audience = allowedAudiences[i];
                    if (audience.endsWith("|" + configuredClientId)) {
                        return true;
                    }
                }
            }
        });

        if (ret === null) {
            foreignMode = true;
        }
        return ret;
    }

    this.getListOfAudiencesFromToken = function (aud, scopes, cid) {
        return extractAudiencesFromToken(aud || [], scopes || [], cid);
    }

    function extractAudiencesFromToken(aud, scopes, cid) {
        var audiences = [];
        var tokenAudiences = aud || [];

        for (var i = 0; i < tokenAudiences.length; ++i) {
            var audience = tokenAudiences[i];
            if (audience.indexOf(DOT) > -1) {
                // CF UAA derives the audiences from the scopes.
                // In case the scopes contains namespaces, these needs to be removed.
                var aud = audience.substring(0, audience.indexOf(DOT)).trim();
                if (aud && !audiences.includes(aud)) {
                    audiences.push(aud);
                }
            } else {
                audiences.push(audience);
            }
        }

        if (audiences.length == 0) {
            for (var i = 0; i < scopes.length; ++i) {
                var scope = scopes[i];
                if (scope.indexOf(DOT) > -1) {
                    var aud = scope.substring(0, scope.indexOf(DOT)).trim();
                    if (aud && !audiences.includes(aud)) {
                        audiences.push(aud);
                    }
                }
            }
        }

        if (cid && audiences.indexOf(cid) === -1) {
            audiences.push(cid);
        }

        return audiences;
    }

    //allow an empty constructor
    if (clientId) {
        this.configureTrustedClientId(clientId);
    }
};

function JwtTokenValidatorIAS(verificationKey, configArray, serviceCredentials) {
    this.isForeignMode = function () {
        return false;
    }

    function checkIssuer(issuer, domains) {
        if(!issuer) {
            throw "issuer is empty";
        }

        //make sure we have a protocol at the beginning of the url
        if(issuer.indexOf('http') !== 0) {
            issuer = "https://" + issuer;
        }
    
        const myURL = new url.URL(issuer);
    
        if(myURL.protocol !== 'https:') {
            if(myURL.hostname !== 'localhost') {
                throw "Issuer has wrong protocol (" + myURL.protocol + ")";
            }            
        }
    
        if(myURL.hash) {
            throw "Issuer has unallowed hash value (" + myURL.hash + ")";
        }
    
        if(myURL.search) {
            throw "Issuer has unallowed query value (" + myURL.search + ")";
        }
    
        for(let i=0;i<domains.length;++i) {
            if(myURL.hostname.endsWith(domains[i])) {
                return;
            }
        }
    
        throw "Issuer not found in domain list " + domains;
    }

    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        //make sure we have at least an array of 1 domain
        const domains = Array.isArray(serviceCredentials.domains) ? serviceCredentials.domains : [serviceCredentials.domain];
        const token = new TokenInfo(accessToken);

        //Issuer validation
        const issuer = token.getIssuer();
        try {
            checkIssuer(issuer, domains)
        } catch(e) {
            return returnError(401, "Issuer validation failed (iss=" + issuer + ") message=" + e);
        }

        return token.verify(verificationKey.getCallback(token), function(err, token) {
            if (err) {
                debugError('\n' + err.message);
                err.statuscode = 401;
                return cb(err);
            }            

            //Audience validation
            let audienceValidator = new JwtAudienceValidator(serviceCredentials.clientid);
            for (var i = 1; i < configArray.length; ++i) {
                if (configArray[i] && configArray[i].clientid) {
                    audienceValidator.configureTrustedClientId(configArray[i].clientid);
                }
            }

            let valid_result = audienceValidator.validateToken(token.getAudiencesArray());
            if (!valid_result.isValid()) {
                return returnError(401, valid_result.getErrorDescription());
            }
            
            cb(null, token);
        });
    }
}

function JwtTokenValidatorXSUAA(verificationKey, configArray, serviceCredentials) {
    var foreignMode = false;

    this.isForeignMode = function () {
        return foreignMode;
    }

    //prepare JWT validators
    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        let tokeninfo = new TokenExchanger(serviceCredentials);

        return tokeninfo.prepareToken(accessToken,
            function (err, token) {
                if (err) {
                    debugError('\n' + err.message);
                    err.statuscode = 401;
                    return cb(err);
                }

                return token.verify(verificationKey.getCallback(token),
                    function (err, token) {                        
                        if (err) {
                            debugError(err.statuscode);
                            debugError(err.message);
                            debugError(err.stack);
                            return cb(err, token);
                        }

                        var decodedToken = token.getPayload();

                        if (!token.getClientId()) {
                            return returnError(400, 'Client Id not contained in access token. Giving up!');
                        }

                        if (!decodedToken.zid) {
                            return returnError(400, 'Identity Zone not contained in access token. Giving up!');
                        }

                        var audienceValidator = new JwtAudienceValidator(configArray[0].clientid);
                        if (configArray[0].xsappname) {
                            audienceValidator.configureTrustedClientId(configArray[0].xsappname);
                        }

                        for (var i = 1; i < configArray.length; ++i) {
                            if (configArray[i]) {
                                if (configArray[i].clientid) {
                                    audienceValidator.configureTrustedClientId(configArray[i].clientid);
                                }
                                if (configArray[i].xsappname) {
                                    audienceValidator.configureTrustedClientId(configArray[i].xsappname);
                                }
                            }
                        }

                        var valid_result = audienceValidator.validateToken(token.getAudiencesArray(), decodedToken.scope, decodedToken.cid);
                        if (!valid_result.isValid()) {
                            return returnError(401, valid_result.getErrorDescription());
                        }

                        if (configArray[0].clientid !== decodedToken.cid) {
                            foreignMode = audienceValidator.isForeignMode();
                        }

                        cb(null, token);
                    }
                );
            })
    };
};

function JwtTokenValidatorUAA(verificationKey, configArray, serviceCredentials) {
    var foreignMode = false;

    this.isForeignMode = function () {
        return foreignMode;
    }

    //prepare JWT validators
    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        let tokeninfo = new TokenExchanger(serviceCredentials, true);

        return tokeninfo.prepareToken(accessToken,
            function (err, token) {
                if (err) {
                    debugError('\n' + err.message);
                    err.statuscode = 401;
                    return cb(err);
                }

                return token.verify(verificationKey.getCallback(token),
                    function (err, token) {                        
                        if (err) {
                            debugError(err.statuscode);
                            debugError(err.message);
                            debugError(err.stack);
                            return cb(err, token);
                        }

                        var decodedToken = token.getPayload();

                        if (!token.getClientId()) {
                            return returnError(400, 'Client Id not contained in access token. Giving up!');
                        }

                        if (!decodedToken.zid) {
                            return returnError(400, 'Identity Zone not contained in access token. Giving up!');
                        }

                        var audienceValidator = new JwtAudienceValidator(configArray[0].clientid);
                        if (configArray[0].xsappname) {
                            audienceValidator.configureTrustedClientId(configArray[0].xsappname);
                        }

                        for (var i = 1; i < configArray.length; ++i) {
                            if (configArray[i]) {
                                if (configArray[i].clientid) {
                                    audienceValidator.configureTrustedClientId(configArray[i].clientid);
                                }
                                if (configArray[i].xsappname) {
                                    audienceValidator.configureTrustedClientId(configArray[i].xsappname);
                                }
                            }
                        }

                        var valid_result = audienceValidator.validateToken(token.getAudiencesArray(), decodedToken.scope, decodedToken.cid);
                        if (!valid_result.isValid()) {
                            return returnError(401, valid_result.getErrorDescription());
                        }

                        if (configArray[0].clientid !== decodedToken.cid) {
                            foreignMode = audienceValidator.isForeignMode();
                        }

                        cb(null, token);
                    }
                );
            })
    };
};

function createJWTTokenValidator(verificationKey, configArray, serviceCredentials) {
    if(verificationKey.getType() === "XSUAA") {
        return new JwtTokenValidatorXSUAA(verificationKey, configArray, serviceCredentials);        
    } else if(verificationKey.getType() === "UAA") {
        return new JwtTokenValidatorUAA(verificationKey, configArray, serviceCredentials);        
    } else {
        return new JwtTokenValidatorIAS(verificationKey, configArray, serviceCredentials);
    }
}

module.exports = {
    JwtAudienceValidator: JwtAudienceValidator,
    createJwtTokenValidator: createJWTTokenValidator
};