'use strict';
const jwtDecode = require('jwt-decode');
const passportUtils = require('../passport/utils');
const xssec = require('@sap/xssec');
const pathUtil = require('../utils/path-util');
const headerUtils = require('../utils/header-util');
const logger = require('../utils/logger');
const vcapUtils = require('../utils/vcap-utils');
const basicAuth = require('basic-auth');
const tokenUtils = require('../utils/token-utils');

module.exports = async function (req, res, next) {
  let auth = req.headers && req.headers['x-approuter-authorization'];
  if (!auth) {
    return next();
  }
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.debug('Incoming request contains x-approuter-authorization header');

  if (req.routerConfig && pathUtil.isPublicPath(req)) {
    tracer.debug('Request to public route with url %s contains x-approuter-authorization header ', req.url);
  }

  if (req.headers['x-approuter-authorization'].startsWith('Basic')){
    const ownCredentials = vcapUtils.getServiceCredentials({label: 'xsuaa'});
    if (ownCredentials) {
      ownCredentials.label = 'xsuaa';
      if (process.env.XSUAA_PRIVATE_KEY){
        ownCredentials.key = process.env.XSUAA_PRIVATE_KEY;
      }
    }
    const creds = basicAuth({headers: {authorization: req.headers['x-approuter-authorization']}});
    if (!creds){
      return writeAuditLog(req, null , `Invalid x-approuter-authorization header for request url ${req.url}`, 401, null, ownCredentials, next);
    }
    try {
      const tenant = req.tenant || getTenant(req,null,ownCredentials);
      const tokenResponse = await tokenUtils.getPasswordUserToken(tenant, creds, ownCredentials, headerUtils.getCorrelationId(req));
      if (req.requiredRoleCollection && (!tokenResponse.tokenDecoded.roleCollections ||
        tokenResponse.tokenDecoded.roleCollections.indexOf(req.requiredRoleCollection) < 0)){
        const tokenKey = tenant + creds.name + creds.pass;
        tokenUtils.deleteTokenCache(tokenKey);
        return writeAuditLog(req, creds.name , `Token validation failed for request url ${req.url}, missing required role collection ${req.requiredRoleCollection}`, 403, creds.name, ownCredentials, next);
      }
      req.headers['x-approuter-authorization'] = `Bearer ${tokenResponse.accessToken}`;
      return handleSession(req,tokenResponse.tokenDecoded, tokenResponse.accessToken,tracer,ownCredentials, next);
    } catch (err){
      return writeAuditLog(req, creds.name , `${err.message} - Token validation failed for request url ${req.url}`, 401, creds.name, ownCredentials, next);
    }
  } else {
    let tokenDecoded;
    try {
      tokenDecoded = jwtDecode(auth);
    } catch (err) {
      let error = new Error('Failed to decode x-approuter-authorization token ' + err);
      error.status = 400;
      return next(error);
    }

    const authArr = auth.split(' ');
    const type = authArr[0];
    const tokenValue = authArr[1];
    let service = getCredentialsAndSecurityType(tokenDecoded);
    if (!service.credentials) {
      return next('No Security service instance bound for service type ' + service.type);
    }
    if (type.toLowerCase() !== 'bearer') {
      writeAuditLog(req, tokenValue, 'x-approuter-authorization header is not a Bearer token', 400, tokenDecoded, service.credentials, next);
      return next();
    }
    const config = {
      credentials: service.credentials,
      correlationId: headerUtils.getCorrelationId(req)
    };
    xssec.createSecurityContext(tokenValue, config, service.type, async function (err) {
      if (err) {
        writeAuditLog(req, tokenValue, `${err.message} - Token validation failed for request url ${req.url}`, 401, tokenDecoded, service.credentials, next);
        return next();
      } else {
        return handleSession(req, tokenDecoded, tokenValue, tracer,service.credentials, next);
      }
    });
  }
};

function writeAuditLog(req, token, errorMessage, errorStatus, tokenDecoded, credentials, next) {
  let auditlogCredentials;
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.error && tracer.error(errorMessage);
  auditlogCredentials = vcapUtils.getServiceCredentials({tag: 'auditlog'});

  let IP = (auditlogCredentials) ? req.headers['x-forwarded-host'] : '******';
  const authorization = (auditlogCredentials) ? token : '******';
  const sourceOfRoute = req.internalUrl ? req.internalUrl.route.source : req.url;
  const message = errorMessage + '- Source of route: ' + sourceOfRoute + ', IP: ' + IP + ', x-approuter-authorization: ' + authorization;

  const loggingData = {};
  loggingData.user = 'Service to Approuter request';
  loggingData.tenantid = getTenant(req, tokenDecoded, credentials);
  logger.writeToAuditLog(req, loggingData, message, function (err) {
    if (err) {
      req && req.logger && req.logger.error('Error occurred when writing to audit log. Error: %s', err.message);
    }
    let error = new Error(errorMessage);
    error.status = errorStatus;
    return next(error);
  });
}

function getTenant(req, tokenDecoded, credentials) {
  let tenant = passportUtils.getUrlTenant(req) || credentials.identityzone;
  if (req.headers['x-subscriber-tenant']) {
    tenant = req.headers['x-subscriber-tenant'];
  } else {
    if (tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn) {
      tenant = tokenDecoded.ext_attr.zdn;
    } else if (tokenDecoded && tokenDecoded['iss']) {
      tenant = getIasTenant(tokenDecoded);
    }
  }
  return tenant;
}

function getIasTenant(tokenDecoded) {
  let temp = tokenDecoded['iss'].split('.')[0].split('/');
  return temp[temp.length - 1];
}

function getCredentialsAndSecurityType(tokenDecoded) {
  let service = {};
  if (tokenDecoded && tokenDecoded.ext_attr) {
    service.credentials = vcapUtils.getServiceCredentials({tag: 'xsuaa'});
    if (process.env.XSUAA_PRIVATE_KEY){
      service.credentials.key = process.env.XSUAA_PRIVATE_KEY;
    }
    service.type = 'XSUAA';
  } else {
    service.credentials = vcapUtils.getServiceCredentials({label: 'identity'});
    if (process.env.IAS_PRIVATE_KEY){
      service.credentials.key = process.env.IAS_PRIVATE_KEY;
    }
    service.type = 'IAS';
  }
  return service;
}

async function handleSession(req, tokenDecoded, tokenValue,tracer,credentials, next){
  const externalSessionStore = req && req.app && req.app.get('externalSessionStore');
  let externalSession = null;
  if (externalSessionStore){
    externalSession =  await externalSessionStore.getExternalSession(tokenDecoded.jti, req);
  }

  if (externalSession) {
    req.session = externalSession;
  } else {
    const tokenContext = {
      accessToken: tokenValue,
      expiresIn: Date.now() + 600000,
      scope: tokenDecoded.scope,
      oauthOptions: credentials
    };
    req.session = {
      externalSessionId: externalSessionStore && tokenDecoded.jti,
      externalSessionExpiration: externalSessionStore && tokenDecoded.exp,
      jwtRefreshStarted: true,
      user: passportUtils.getUserProperties(tokenContext),
      req: req,
      reload: function (cb) {
        cb();
      },
      save: function () {
      },
      touch: function () {
      }
    };
    if (externalSessionStore){
      await externalSessionStore.updateExternalSession(req.session);
    }
  }
  tracer.info('Session created successfully');
  return next();
}
