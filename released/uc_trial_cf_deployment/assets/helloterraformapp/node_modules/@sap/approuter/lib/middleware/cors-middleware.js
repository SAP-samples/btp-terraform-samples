'use strict';

const _ = require ('lodash');
const url = require ('url');
const urlUtils = require('../utils/url-utils');
const whitelistUtil = require('../utils/whitelist-utils');

module.exports = function processCors(req, res, next) {

  if (!req.headers['origin']) {
    return next();
  }

  let originURL = url.parse (req.headers['origin']);

  if (!isOriginValid (originURL)) {
    return next(getForbiddenError ('Invalid origin header value.'));
  }

  if (isLocalOrigin (req, req.headers['origin'])) {
    return next();
  }

  let corsDefinition = getCorsDefinition (req);
  if (!corsDefinition) {
    return next();
  }

  let corsConfigWithDefaults = fillDefaultsCorsConfig(corsDefinition);

  if (req.method === 'OPTIONS' && req.headers['access-control-request-method']) {
    processPreflight(req, res, originURL, corsConfigWithDefaults, next);
  }
  else {
    processActualRequest (req, res, originURL, corsConfigWithDefaults, next);
  }
};

function getCorsDefinition (req) {
  let envCors = req.routerConfig.cors;
  let xsappCorsData;
  let xsappCors = req.routerConfig.appConfig.cors;
  if (!envCors && !xsappCors)
  {
    return;
  }
  if (envCors && !xsappCors)
  {
    return _.find(envCors, function (envCors) {
      return envCors.uriPattern.test(req.url);
    });
  }
  if (!envCors && xsappCors)
  {
    return _.find(xsappCors, function (xsappCors) {
      return xsappCors.uriPattern.test(req.url);
    });
  }
  if (envCors && xsappCors)
  {
    xsappCorsData = _.find(xsappCors, function (xsappCors) {
      return xsappCors.uriPattern.test(req.url);
    });
    if (!xsappCorsData)
    {
      return _.find(envCors, function (envCors) {
        return envCors.uriPattern.test(req.url);
      });
    }
    else
    {
      return xsappCorsData;
    }
  }
}

function isLocalOrigin (req, origin) {
  let appRouterUrl = urlUtils.parse(urlUtils.buildAppRouterUrl(req));
  let target = '';

  let protocol = appRouterUrl.protocol.slice(0, -1);
  if (!protocol) {
    return false;
  }
  target += protocol + '://';

  let host = appRouterUrl.hostname;
  if (!host) {
    return false;
  }
  target += host;

  let port = appRouterUrl.port;
  if (port && ((protocol === 'http' && port !== 80) ||
               (protocol === 'https' && port !== 443))) {
    target += ':' + port;
  }

  return (target.toLowerCase() === origin.toLowerCase());
}

function isOriginValid (originURL) {
  if (!originURL.protocol || !originURL.hostname || _.includes(originURL.href, '%')) {
    return false;
  }
  return true;
}

function getForbiddenError (errorString) {
  let error = new Error(errorString);
  error.status = 403;
  return error;
}

function isOriginAllowed (corsDefinition, originURL) {
  if (!originURL.port) {
    if (originURL.protocol.slice(0, -1) === 'http') {
      originURL.host += ':80';
    }
    else if (originURL.protocol.slice(0, -1) === 'https') {
      originURL.host += ':443';
    }
  }

  return whitelistUtil.matchWithUrl(corsDefinition.allowedOrigin, originURL);
}

function isAnyOriginAllowed (corsDefinition) {
  return corsDefinition.allowedOrigin.some (function (allowedOrigin) {
    return (allowedOrigin.host === '*' && !allowedOrigin.protocol && !allowedOrigin.port);
  });
}

function isMethodAllowed (req, corsDefinition) {
  return _.includes(corsDefinition.allowedMethods, req.method);
}

function processActualRequest (req, res, originURL, corsDefinition, next) {
  if (!isOriginAllowed (corsDefinition, originURL)) {
    return next(getForbiddenError ('Origin is not allowed.'));
  }

  if (!isMethodAllowed (req, corsDefinition)) {
    return next(getForbiddenError ('Method is not allowed.'));
  }

  let anyOriginAllowed = isAnyOriginAllowed (corsDefinition);
  if (anyOriginAllowed && !corsDefinition.allowedCredentials) {
    res.setHeader('access-control-allow-origin', '*');
  }
  else {
    res.setHeader('access-control-allow-origin', req.headers['origin']);
  }

  if (corsDefinition.allowedCredentials) {
    res.setHeader('access-control-allow-credentials', 'true');
  }

  if (corsDefinition.exposeHeaders && corsDefinition.exposeHeaders.length > 0) {
    let exposedHeaders = corsDefinition.exposeHeaders.join(', ');
    res.setHeader('access-control-expose-headers', exposedHeaders);
  }

  next();
}


let DEFAULT_ALLOWED_METHODS = [
  'GET',
  'POST',
  'HEAD',
  'OPTIONS'
];

let DEFAULT_ALLOWED_HEADERS = [
  'Origin',
  'Accept',
  'X-Requested-With',
  'Content-Type',
  'Access-Control-Request-Method',
  'Access-Control-Request-Headers'
];

function processPreflight(req, res, originURL, corsDefinition, next) {

  let responseHeaders = {};

  if (!isOriginAllowed(corsDefinition, originURL)) {
    return next(getForbiddenError('Origin not allowed'));
  }

  let requestMethod = req.headers['access-control-request-method'];
  let hasMethodMatch  = _.includes(corsDefinition.allowedMethods, requestMethod);
  if (!hasMethodMatch) {
    return next(getForbiddenError('Access-Control-Request-Method is not allowed'));
  }

  let header = req.headers['access-control-request-headers'];
  if (header) {
    let requestHeaders = header.replace(' ', '').split(',');
    let headersMatching = _.intersection(_.map(requestHeaders, _.toLower), _.map(corsDefinition.allowedHeaders, _.toLower));
    if (headersMatching.length !== requestHeaders.length) {
      return next(getForbiddenError('Not all requested Access-Control-Request-Headers are allowed'));
    }
  }

  let origin = req.headers['origin'];
  let supportCredentials = corsDefinition.allowedCredentials;
  if (supportCredentials) {
    responseHeaders['access-control-allow-credentials'] = 'true';
    responseHeaders['access-control-allow-origin'] = origin;
  }
  else {
    if (isAnyOriginAllowed(corsDefinition)) {
      responseHeaders['access-control-allow-origin'] = '*';
    }
    else {
      responseHeaders['access-control-allow-origin'] = origin;
    }
  }

  let maxAge = corsDefinition.maxAge;
  if (maxAge > 0) {
    responseHeaders['access-control-max-age'] = maxAge;
  }

  responseHeaders['access-control-allow-methods'] = requestMethod;
  responseHeaders['access-control-allow-headers'] = corsDefinition.allowedHeaders.join(', ');

  send(res, responseHeaders);
}

function fillDefaultsCorsConfig(corsConfig) {
  let corsConfigWithDefaults = {};

  corsConfigWithDefaults.uriPattern = corsConfig.uriPattern;
  corsConfigWithDefaults.allowedOrigin = Array.isArray(corsConfig.allowedOrigin) && corsConfig.allowedOrigin.length > 0 ? corsConfig.allowedOrigin : [{'host': '*'}];
  corsConfigWithDefaults.allowedMethods = corsConfig.hasOwnProperty('allowedMethods') && Array.isArray(corsConfig.allowedMethods) && corsConfig.allowedMethods.length > 0 ? corsConfig.allowedMethods : DEFAULT_ALLOWED_METHODS;
  corsConfigWithDefaults.allowedHeaders = corsConfig.hasOwnProperty('allowedHeaders') && Array.isArray(corsConfig.allowedHeaders) && corsConfig.allowedHeaders.length > 0 ? corsConfig.allowedHeaders : DEFAULT_ALLOWED_HEADERS;
  corsConfigWithDefaults.maxAge = corsConfig.hasOwnProperty('maxAge') && corsConfig.maxAge >= 0 ?  corsConfig.maxAge : 1800;
  corsConfigWithDefaults.allowedCredentials = corsConfig.hasOwnProperty('allowedCredentials') ? corsConfig.allowedCredentials : true;
  corsConfigWithDefaults.exposeHeaders = corsConfig.exposeHeaders;

  return corsConfigWithDefaults;
}

function send(res, responseHeaders) {
  for (let headerName in responseHeaders){
    res.setHeader(headerName, responseHeaders[headerName]);
  }
  res.status = 200;
  return res.end();
}