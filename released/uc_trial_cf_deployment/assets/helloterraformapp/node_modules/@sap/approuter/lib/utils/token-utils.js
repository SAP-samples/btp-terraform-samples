/* eslint-disable camelcase */
'use strict';

const xsenv = require('@sap/xsenv');
const validators = require('../configuration/validators');
const passportUtils = require('../passport/utils');
const loggerUtils = require('./logger');
const headerUtils = require('./header-util');
const tracer = loggerUtils.getTracer(__filename);
const url = require('url');
const request = require('./request-utils');
const NodeCache = require('node-cache');
const xssec = require('@sap/xssec');
const jarCache = new NodeCache({stdTTL: 300, checkperiod: 320, useClones: false});
const jwtDecode = require('jwt-decode');
const {CookieJar} = require('tough-cookie');
const {promisify} = require('util');
const tokenCache = {};

const cacheKey = 'kibanaJar';

exports.getTokens = getBSTokens;
exports.loadClientCredentialsToken = loadClientCredentialsToken;
exports.getClientCredentialsTokenByTenant = getClientCredentialsTokenByTenant;
exports.getClientCredentialsToken = getClientCredentialsToken;
exports.getAuthenticationJar = getAuthenticationJar;
exports.exchangeToken = exchangeToken;
exports.getRefreshToken = getRefreshToken;
exports.getTokenInfo = getTokenInfo;
exports.getPasswordUserToken = getPasswordUserToken;
exports.deleteTokenCache = deleteTokenCache;

function getBSTokens(app) {
  if (process.env.SKIP_CLIENT_CREDENTIALS_TOKENS_LOAD) {
    if (!app.services) {
      app.services = {};
    }
    return;
  }
  const DESTINATION = 'destination';
  const CONNECTIVITY = 'connectivity';
  const CLIENT_CREDENTIALS = 'client_credentials';

  const services = xsenv.readServices();
  if (services) {
    for (const serviceName in services) {
      const service = services[serviceName];
      if (service.credentials && (service.label === DESTINATION || service.label === CONNECTIVITY || service.credentials['grant_type'] === CLIENT_CREDENTIALS)) {
        validators.validateClientCredentials(service.credentials);
        loadClientCredentialsToken(app, headerUtils.getCorrelationId(), service.credentials, service.credentials['sap.cloud.service'] || service.label);
      }
    }
  }
}

function getTokenInfo(token){
  try {
    if (token.startsWith('Bearer')){
      token = token.split(' ')[1];
    }
    const tokenDecoded = jwtDecode(token);
    return {
      subdomain: tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn,
      serviceInstanceId: tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.serviceinstanceid,
      clientId: tokenDecoded.client_id,
      expiration: tokenDecoded.exp,
      roleCollections: tokenDecoded['xs.system.attributes'] && tokenDecoded['xs.system.attributes']['xs.rolecollections']
    };
  } catch (err){
    return {
      invalidToken: err
    };
  }
}

function getClientCredentialsTokenByTenant(correlationId, tenant, credentials, zoneInfo, cb) {
  const config = createConfigObject(credentials.uaa || credentials, correlationId, 5000);
  return xssec.requests.requestClientCredentialsToken(tenant, config, null, zoneInfo && zoneInfo.zoneId || null, (err, accessToken, tokenInfo) => {
    let tokenResponseOptions = handleClientCredentialsTokenResponse(createTokenResponseOptions(err, tokenInfo, credentials.label, tenant, correlationId));
    if (tokenResponseOptions.errorMessage) {
      return cb(new Error(tokenResponseOptions.errorMessage));
    }
    cb(null, tokenResponseOptions);
  });
}

function loadClientCredentialsToken(app, correlationId, credentials, serviceName, cb) {
  const config = createConfigObject(credentials.uaa || credentials, correlationId, 5000);
  xssec.requests.requestClientCredentialsToken(null, config, null, null, (err, accessToken, tokenInfo) => {
    let tokenResponseOptions = handleClientCredentialsTokenResponse(createTokenResponseOptions(err, tokenInfo, serviceName, credentials.identityzone, correlationId));
    if (tokenResponseOptions.errorMessage) {
      tracer.error(tokenResponseOptions.errorMessage);
      return cb ? cb(err || tokenResponseOptions.errorMessage) : null;
    }
    if (!app.services) {
      app.services = {};
    }
    app.services[serviceName] = {token: tokenResponseOptions};
    const FIVE_MINUTES = 5 * 60 * 1000;
    const tokenRefreshTimestamp = passportUtils.getExpiresAt(tokenInfo.expires_in).getTime() - FIVE_MINUTES;
    const msBeforeRetrieval = tokenRefreshTimestamp - Date.now();
    setTimeout(function () {
      loadClientCredentialsToken(app, correlationId, credentials, serviceName);
    }, msBeforeRetrieval);
    return cb ? cb() : null;
  });
}

function getAuthenticationJar(cb) {
  const cachedJar = jarCache.get(cacheKey);
  if (cachedJar && cachedJar._jar && cachedJar._jar.store) {
    return cb(null, cachedJar);
  }
  const requestOptions = {
    url: process.env.UAA_URL + '/oauth/token?login_hint=%7B%22origin%22%3A%22sap.ids%22%7D',
    form: {
      username: process.env.UAA_USER,
      password: process.env.UAA_PASSWORD,
      client_id: 'cf',
      client_secret: '',
      'grant_type': 'password',
      response_type: 'token'
    },
    timeout: 10000
  };

  request.post(requestOptions,  function onResponse(err, res, body) {
    let accessToken = null;
    if (err || !body) {
      const error = new Error('Failed to get UAA token ' + err + ' ' + body ? body : '');
      error.status = 403;
      return cb(error);
    }
    try {
      accessToken = JSON.parse(body).access_token;
      const jar = new CookieJar();
      getState(accessToken, jar, function (err, state, jar) {
        if (err) {
          return cb(err);
        }
        return getJarContent(jar, state, accessToken, cb);
      });
    } catch (err) {
      return cb(new Error('Failed to parse UAA token ' + err + ' ' + accessToken));
    }
  });
}

function getState(accessToken, jar, cb) {
  const url = process.env.LOGS_URL + '/app/kibana#/discover';
  const requestOptions = {
    url: url,
    jar: jar,
    followRedirect: false
  };
  request.get(requestOptions, async function onResponse(err, res, body) {
    const stateIndex = body.indexOf(';state=');
    if (stateIndex === -1) {
      return cb(new Error('No state variable found in discovery for url: ' + url + ', response was: ' + res.body));
    }
    // eslint-disable-next-line no-useless-escape
    const stateFinished = body.indexOf('\">');
    const state = body.substring(stateIndex + 7, stateFinished);
    const cookies = res.headers['set-cookie'] || [];
    const setCookie = promisify(jar.setCookie.bind(jar));
    for (const cookieString of cookies) {
      await setCookie(cookieString, process.env.LOGS_URL);
    }
    cb(null, state, jar);
  });
}

function getClientId(cb) {
  request.get({url: process.env.LOGS_URL, followRedirect: false}, (err, response) => {
    if (err || response.statusCode !== 302) {
      return cb(err);
    }
    const query = url.parse(response.headers.location, true).query;
    cb(null, query.client_id);
  });
}

function getJarContent(jar, state, accessToken, cb) {
  getClientId((err, clientID) => {
    const url = process.env.UAA_URL + '/oauth/authorize?grant_type=authorization_code&client_id=' +
      clientID + '&response_type=code&state=' + state +
      '&login_hint=%7B%22origin%22%3A%22uaa%22%7D&redirect_uri=' +
      encodeURIComponent(process.env.LOGS_URL + '/authorization');
    const requestOptions = {
      url: url,
      jar: jar,
      headers: {
        Authorization: 'bearer ' + accessToken
      }
    };
    request.get(requestOptions, function onResponse(err) {
      if (err) {
        return cb(err);
      }
      jarCache.set(cacheKey, jar);
      cb(null, jar);
    });
  });
}

function exchangeToken(loginToken, correlationId, externalServiceCredentials, cb) {
  try {
    const tokenDecoded = loginToken && loginToken.length > 100 ? jwtDecode(loginToken) : null;
    const subdomain = tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn;
    const zoneId = tokenDecoded && tokenDecoded.zone_uuid;
    const config = createConfigObject(externalServiceCredentials, correlationId, null);
    xssec.requests.requestUserToken(loginToken, config, null, null, subdomain, zoneId, (err, token, tokenJson) => {
      if (err){
        let errorSource = err.response && err.response.data && err.response.data.error
          ? ' - ' + err.response.data.error + ' - ' + err.response.data.error_description
          : err.response && err.response.data ? ' - ' + err.response.data : '';
        err.message = 'Failed to exchange token: ' + err.message + errorSource + ', token details - ' + JSON.stringify(getTokenInfo(loginToken)) +
          ', external service credentials details - identityzone:  ' + externalServiceCredentials.identityzone + ' clientid: ' + externalServiceCredentials.clientid;
        cb(err);
      } else {
        cb(null,token, tokenJson);
      }
    });
  } catch (err) {
    cb('Failed to exchange token ' + err + ', token details: ' + JSON.stringify(getTokenInfo(loginToken)));
  }
}

function getClientCredentialsToken(subdomain, correlationId, credentials, zoneId) {
  return new Promise((resolve, reject) => {
    const config = createConfigObject(credentials, correlationId, 5000);
    xssec.requests.requestClientCredentialsToken(subdomain, config, null, zoneId, (err, token, tokenJson) => {
      let tokenResponseOptions = handleClientCredentialsTokenResponse(createTokenResponseOptions(err, tokenJson, credentials.label, subdomain, correlationId));
      if (tokenResponseOptions.errorMessage) {
        reject(tokenResponseOptions.errorMessage);
      }
      resolve(tokenResponseOptions);
    });
  });
}

function deleteTokenCache(tokenKey){
  if (tokenCache[tokenKey]){
    delete tokenCache[tokenKey];
  }
}

function getPasswordUserToken(subdomain, userCreds, credentials, correlationId) {
  return new Promise((resolve, reject) => {
    const tokenKey = subdomain + userCreds.name + userCreds.pass;
    if (tokenCache[tokenKey] && tokenCache[tokenKey].tokenRefreshTimestamp > Date.now()){
      return resolve(tokenCache[tokenKey]);
    }
    const config = createConfigObject(credentials, correlationId, 5000);
    config.username = userCreds.name;
    config.password = userCreds.pass;
    xssec.requests.requestPasswordUserToken(subdomain, config, null, (err, token, tokenJson) => {
      const tokenResponseOptions = handleUserTokenResponse(createTokenResponseOptions(err, tokenJson, credentials.label, subdomain, correlationId),tokenJson);
      if (tokenResponseOptions.errorMessage) {
        return reject(new Error(tokenResponseOptions.errorMessage));
      }
      tokenCache[tokenKey] = tokenResponseOptions;
      resolve(tokenResponseOptions);
    });
  });
}

function getRefreshToken(accessToken, uaaOptions) {
  const requestOptions = {
    url: uaaOptions.tokenURL,
    headers: {
      'content-type': 'application/x-www-form-urlencoded;charset=utf-8',
      'accept': 'application/json;charset=utf-8',
      'Authorization': `Bearer ${accessToken}`
    },
    form: {
      'client_id': uaaOptions.clientid,
      'grant_type': 'user_token',
      'token_format': 'jwt'
    }
  };
  return new Promise((resolve, reject) => {
    request.post(requestOptions, (err, res, body) => {
      if (err || !body) {
        reject(`Failed to create refresh token ${err}`);
      }
      try {
        const tokenData = JSON.parse(body);
        tokenData.refresh_token ? resolve(tokenData) : reject(`Failed to parse token ${body}`);
      } catch (err) {
        reject(`Failed to parse refresh token ${err}`);
      }
    });
  });
}

function createTokenResponseOptions(err, token, serviceName, subaccount, correlationId) {
  return {
    err: err,
    accessToken: token && token.access_token,
    expiration: token && token.expires_in,
    tokenType: token && token.token_type,
    serviceName: serviceName,
    subaccount: subaccount,
    correlationId: correlationId
  };
}

function handleClientCredentialsTokenResponse(tokenResponseOptions) {
  let result = {};
  if (tokenResponseOptions.err) {
    result.errorMessage = 'Error getting client_credentials token for ' + tokenResponseOptions.serviceName + ' from subaccount ' + tokenResponseOptions.subaccount + ' error: ' + tokenResponseOptions.err.message;
  } else if (!tokenResponseOptions.accessToken || !tokenResponseOptions.expiration) {
    result.errorMessage = new Error('Bad response from UAA when getting client credentials token for ' + tokenResponseOptions.serviceName + ' - not all fields are present');
  } else if (process.env.MINIMUM_TOKEN_VALIDITY && (tokenResponseOptions.expiration < process.env.MINIMUM_TOKEN_VALIDITY)) {
    result.errorMessage = new Error(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} is lower than the minimum token validity of
     ${process.env.MINIMUM_TOKEN_VALIDITY} seconds, please increase token validity above this value. To set the token validity on subaccount level refer to: https://api.sap.com/api/SecuritySettingsAPI/resource`);
  } else {
    tracer.info(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} with correlationId ${tokenResponseOptions.correlationId} is ${tokenResponseOptions.expiration}`);
    result = createTokenOptions(tokenResponseOptions.accessToken, tokenResponseOptions.tokenType, passportUtils.getExpiresAt(tokenResponseOptions.expiration).getTime());
  }
  return result;
}

function handleUserTokenResponse(tokenResponseOptions, tokenDecoded) {
  let result = {};
  if (tokenResponseOptions.err) {
    result.errorMessage = 'Error getting user token for ' + tokenResponseOptions.serviceName + ' from subaccount ' + tokenResponseOptions.subaccount + ' error: ' + tokenResponseOptions.err.message;
  } else if (!tokenResponseOptions.accessToken || !tokenResponseOptions.expiration) {
    result.errorMessage = new Error('Bad response from UAA when user token for ' + tokenResponseOptions.serviceName + ' - not all fields are present');
  } else {
    tracer.info(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} with correlationId ${tokenResponseOptions.correlationId} is ${tokenResponseOptions.expiration}`);
    let tokenInfo = getTokenInfo(tokenDecoded.access_token);
    tokenDecoded.exp = tokenInfo.expiration;
    tokenDecoded.roleCollections = tokenInfo.roleCollections;
    result = createTokenOptions(tokenResponseOptions.accessToken, tokenResponseOptions.tokenType, passportUtils.getExpiresAt(tokenResponseOptions.expiration).getTime(), tokenDecoded);
  }
  return result;
}

function createConfigObject(credentials, correlationId, timeout) {
  return {
    credentials: credentials,
    correlationId: correlationId,
    timeout: timeout
  };
}

function createTokenOptions(accesToken, tokenType, timeStamp, tokenDecoded) {
  return {
    accessToken: accesToken,
    tokenType: tokenType,
    tokenRefreshTimestamp: timeStamp,
    tokenDecoded: tokenDecoded
  };
}