'use strict';
const destinationUtils = require('../../lib/utils/destination-utils');
const tokenUtils = require('../../lib/utils/token-utils');
const jwtDecode = require('jwt-decode');
const expiresAt = require('../passport/utils').getExpiresAt;
const validators = require('../configuration/validators');
const passportUtils = require('../passport/utils');

const self = module.exports = {

  retrieveDestination: function (options, cb) {
    self.replaceUserToken(options, function (err, userExchangeToken) {
      if (err) {
        return cb(err);
      }
      let destinationName = options.destinationName;
      let accessToken = userExchangeToken && userExchangeToken.access_token ? userExchangeToken.access_token : userExchangeToken;
      destinationUtils.findDestination(destinationName, accessToken, options, function (err, destinationLookUpResult) {
        if (err) {
          return cb(err);
        }
        try {
          if (!destinationLookUpResult || !destinationLookUpResult.destinationConfiguration) {
            return cb('Cannot get destination configuration for destination ' + destinationName);
          }
          if (destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].hasOwnProperty('error')) {
            return cb(destinationLookUpResult.authTokens[0].error);
          }
          if (destinationLookUpResult.authTokens) {
            const authTokenExpiresIn = destinationLookUpResult.authTokens[0].expires_in;
            destinationLookUpResult.authTokens[0].expireDate = authTokenExpiresIn ? expiresAt(authTokenExpiresIn).getTime() : 0;
          }
          let result = {};
          if (userExchangeToken) {
            const tokenDecoded = jwtDecode(userExchangeToken);
            const expMs = tokenDecoded.exp * 1000;
            const threeMins = 180000;
            result.userExchangeToken = {
              token: userExchangeToken,
              expireDate: expMs > threeMins ? expMs - threeMins : expMs,
              destinationKey: options.destinationKey
            };
          }
          let destinationsConfigurations = [destinationLookUpResult.destinationConfiguration];
          destinationUtils.normalizeDestinationProperties(destinationsConfigurations);
          const normalizedCertificateProperties = destinationUtils.isDestinationCertificatesFlow(destinationsConfigurations[0])
              && destinationUtils.normalizeCertificateProperties(destinationLookUpResult.certificates);
          validators.validateDestinations(destinationsConfigurations);
          destinationUtils.adjustDestinationProperties(destinationsConfigurations);
          result.destination = destinationsConfigurations[0];
          result.expireDate = destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].expireDate;
          if (options.dynamicDestination && !result.destination.dynamicDestination) {
            return cb('Destination ' + destinationName + ' is not defined as a dynamic destination in destination service, configure additional property HTML5.DynamicDestination true');
          }
          result.authToken = destinationLookUpResult.authTokens ? destinationLookUpResult.authTokens[0] : null;
          result.destination.certificates = normalizedCertificateProperties && destinationUtils.getDestinationCertificate(destinationsConfigurations[0], normalizedCertificateProperties);
          return cb(null, result);
        } catch (error) {
          return cb(error);
        }
      });
    });
  },

  isDestinationServiceFlow: function (internalUrl) {
    if (!internalUrl || !internalUrl.route || !internalUrl.route.destination || !internalUrl.destination ||
        internalUrl.destination.url !== 'DESTINATION_URL_PLACEHOLDER') {
      return false;
    }
    return true;
  },

  replaceUserToken: function (options, cb) {
    let session = options.session;
    if (!session || !session.user || session.user.name === passportUtils.USER_NAME_NOT_APPLICABLE) {
      return cb(null);
    }
    shouldRequestUserExchangeToken(session, options.destinationKey, function (err, askForToken) {
      if (err) {
        return cb(err);
      }
      if (!askForToken) {
        let userExchangeToken = options.destinationKey && session.user.destinationKey && session.user.destinationKey[options.destinationKey]
          ? session.user.destinationKey[options.destinationKey].destinationUserExchangeToken.token : session.user.destinationUserExchangeToken.token;
        return cb(null, userExchangeToken);
      }
      getExternalServiceCredentials(options, (err, externalServiceCredentials) => {
        if (err) {
          return cb('Failed to get external service credentials ' + err);
        }
        if (!options.session.user.token) {
          return cb(`Missing token for session user. correlationId: ${options.correlationId}`);
        }
        let jwt = options.jwt || options.session.user.token.accessToken;
        return tokenUtils.exchangeToken(jwt, options.correlationId, externalServiceCredentials, cb);
      });
    });
  },
  addDestinationHeaders: function (req) {
    if (req.headers && req.internalUrl && req.internalUrl.destination) {
      const escapeHeaders = Object.keys(req.headers);
      for (const destinationKey in req.internalUrl.destination) {
        if (destinationKey.startsWith('uRL.headers')) {
          const headerKey = destinationKey.split('.')[2];
          if (headerKey && !escapeHeaders.includes(headerKey)) {
            req.headers[headerKey] = req.internalUrl.destination[destinationKey];
          }
        }
      }
    }
    return req;
  }
};

function shouldRequestUserExchangeToken(session, destinationKey, cb) {
  let destinationTokensCache = destinationKey && session.user.destinationKey && session.user.destinationKey[destinationKey]
    ? session.user.destinationKey[destinationKey].destinationUserExchangeToken : session.user.destinationUserExchangeToken;

  // check the expiration of destinationUserExchangeToken
  if (!destinationTokensCache || (destinationKey && (destinationKey !== destinationTokensCache.destinationKey)) || (!destinationTokensCache.token || destinationTokensCache.expireDate < Date.now())) {
    return cb(null, true);
  }
  return cb(null, false);
}

function getExternalServiceCredentials(options, cb){
  let externalServiceCredentials;
  if (options.destinationKey && options.app && options.app.services[options.destinationKey]) {
    destinationUtils.getDestinationCredentialsByDestinationKey(options.app, options.destinationKey, options.correlationId, (err, destCredentials) => {
      if (err) {
        return cb(err);
      }
      externalServiceCredentials = destCredentials;
      externalServiceCredentials.url = externalServiceCredentials.tokenServiceURL;
      externalServiceCredentials.clientid = externalServiceCredentials.clientId;
      externalServiceCredentials.clientsecret = externalServiceCredentials.clientSecret;
      return cb(null, externalServiceCredentials);
    });
  } else {
    externalServiceCredentials = options.destinationCredentials || destinationUtils.getDestinationServiceCredentials();
    cb(null, externalServiceCredentials);
  }
}