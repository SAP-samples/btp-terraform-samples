'use strict';

const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const VError = require('verror').VError;
const safeRegex = require('safe-regex');
const xsenv = require('@sap/xsenv');
const loggingUtils = require('../utils/logger');
const tracer = loggingUtils.getTracer(__filename);
const logger = loggingUtils.getLogger('/Configuration');
const fsUtils = require('../utils/fs-utils');
const validators = require('./validators');
const prettyPrint = require('../utils/pretty-print');
const configurationUtils = require('../utils/configuration-utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');

exports.loadConfiguration = function (directory, source, envDestinations, appName) {
  let configuration = _.isObject(source) ? source : loadXsAppFromFile(directory, source);

  validators.validateXsApp(configuration, envDestinations, directory);
  if (configuration.authenticationMethod === 'none') {
    logger.warning('No authentication will be used when accessing backends. Scopes defined in routes will be ignored.');
  }

  configuration.routes = configuration.routes || [];
  let hasLocalDirSet = configuration.routes.some(function (currentRoute) {
    return !!currentRoute.localDir;
  });

  if (!hasLocalDirSet) {
    if (fsUtils.isDirectory(path.join(directory, 'resources'))) {
      configuration.routes.push({
        source: '^/(.*)',
        localDir: 'resources'
      });
    } else {
      if (!dynamicRoutingUtils.isDynamicRouting()) {
        logger.info('xs-app.json: Application does not have directory for static resources!');
      }
    }
  }

  processRoutes(configuration, appName);
  processCors(configuration);
  processCompressResponseMixedTypeContent(configuration);
  handleReplace(configuration, directory);
  configuration.errorPage = generateErrorPageMap(configuration);
  return configuration;
};

function loadXsAppFromFile(directory, source) {
  let fullFileName = path.join(directory, source);

  try {
    tracer.info('Loading configuration from ', fullFileName);
    return JSON.parse(fs.readFileSync(fullFileName, 'utf8'));
  } catch (e) {
    throw new VError(e, 'Invalid content in %s', fullFileName);
  }
}

function generateErrorPageMap(configuration) {
  return (configuration.errorPage || []).reduce(function (result, errorRoute) {
    let arr = Array.isArray(errorRoute.status) ? errorRoute.status : [errorRoute.status];
    arr.forEach(function (status) {
      result.set(status, errorRoute.file);
    });
    return result;
  }, new Map());
}

function handleReplace(configuration, workingDir) {
  let pathToDefaultServices = path.join(workingDir, 'default-services.json');
  configuration.routes.forEach(function (route) {
    if (route.replace) {
      let varsMap = {};
      if (route.replace.vars) {
        varsMap = route.replace.vars.reduce(function (result, varName) {
          result[varName] = process.env[varName];
          return result;
        }, varsMap);
      }
      let services = route.replace.services ?
        xsenv.getServices(route.replace.services, pathToDefaultServices) : {};

      let common = _.intersection(Object.keys(varsMap), Object.keys(services));
      if (common.length > 0) {
        throw new VError('Route has invalid replace object - colliding services and vars: %s', common);
      }
      route.replace.view = _.extend(varsMap, services);
    }
  });
}

function processRoutes(configuration, appName) {
  if (!appName) {
    logger.info("Replacing $XSAPPNAME will not take place - 'xsappname' property not found in UAA configuration.");
  }

  configuration.routes.forEach(function (currentRoute) {
    currentRoute.source = configurationUtils.constructRegExp(currentRoute.source);
    if (!safeRegex(currentRoute.source)) {
      logger.warning('Route with source ', currentRoute.source, ' is vulnerable to ReDoS attacks');
    }
    if (currentRoute.authenticationType === 'none' && currentRoute.scope) {
      logger.warning('Route with source ', currentRoute.source, ' does not require authentication. Defined scopes will be ignored.');
    }

    currentRoute.scope = processScope(currentRoute.scope, appName);
  });
  if (tracer.isEnabled('debug')) {
    tracer.debug('Routes after being processed', JSON.stringify(configuration.routes, prettyPrint.prettyPrintRegExp, 2));
  }
}

function processCors(configuration) {
  if (!configuration.cors) {
    return [];
  }
  validators.validateCors(configuration.cors);
  configuration.cors.forEach(function (currentCors) {
    currentCors.uriPattern = configurationUtils.constructRegExp(currentCors.uriPattern);
    if (!safeRegex(currentCors.uriPattern)) {
      logger.warning('Cors configuration with uriPattern ', currentCors.uriPattern, ' is vulnerable to ReDoS attacks');
    }
  });
  if (tracer.isEnabled('debug')) {
    tracer.debug('Cors after being processed', JSON.stringify(configuration.cors, prettyPrint.prettyPrintRegExp, 2));
  }
}

function processCompressResponseMixedTypeContent(configuration) {
  if (!configuration.compression || (configuration.compression && !configuration.compression.compressResponseMixedTypeContent)) {
    configuration.compression.compressResponseMixedTypeContent = false;
    return;
  }
  validators.validateType(configuration.compression.compressResponseMixedTypeContent,'compressResponseMixedTypeContent', 'boolean');
}

function processScope(scope, appName) {
  if (_.isString(scope) || Array.isArray(scope)) {
    return replaceApplicationName(scope, appName);
  }
  for (let httpMethod in scope) {
    scope[httpMethod] = replaceApplicationName(scope[httpMethod], appName);
  }
  return scope;
}

function replaceApplicationName(scope, appName) {
  scope = _.isString(scope) ? [scope] : scope;
  if (!appName) {
    return scope;
  }
  return scope.map(function (scopeName) {
    return scopeName.replace(/^\$XSAPPNAME/, appName);
  });
}