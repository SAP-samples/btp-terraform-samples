'use strict';

const tokens = require('../utils/csrf-utils')({'secretLength': 32});
const pathUtil = require('../utils/path-util');
const sessionExt = require('../utils/session-ext');
const logoutProvider = require('./logout-provider');

module.exports = {
  /**
   * Checks if a token is required for an incoming request:
   *  - GET and HEAD requests do not require a token (except if they are used to fetch a new token)
   *  - public path requests do not require a token
   *
   * @param req
   * @returns true if a token is required, else false
   */
  isTokenRequired: function (req) {
    const storeCSRFInExternalSession = process.env.SVC2AR_STORE_CSRF_IN_EXTERNAL_SESSION
        && (process.env.SVC2AR_STORE_CSRF_IN_EXTERNAL_SESSION === 'true' || process.env.SVC2AR_STORE_CSRF_IN_EXTERNAL_SESSION === true);

    if (req.headers['x-approuter-authorization'] &&
        !(req.app && req.app.get('externalSessionStore') && storeCSRFInExternalSession)) {
      return false;
    }
    if (logoutProvider.isLogoutRequest(req)) {
      if (!logoutProvider.isLogoutCsrfProtectionEnabled(req)) {
        return false;
      }
    } else if (!pathUtil.isCsrfProtectionEnabled(req)) {
      return false;
    }

    if (isGetRequest(req) || isHeadRequest(req)) {
      return hasTokenFetchHeader(req);
    }

    return !pathUtil.isPublicPath(req);
  },

  isTokenFetchRequest: function (req) {
    return ((isGetRequest(req) || isHeadRequest(req)) && hasTokenFetchHeader(req));
  },

  /**
   * Check a token send by the client
   *
   * @param req
   * @returns {isValid: boolean, details: string}
   */
  checkToken: function (req) {
    const tokenHeader = req.headers['x-csrf-token'];
    if (!tokenHeader) {
      return {isValid: false, details: 'The request does not contain a x-csrf-token'};
    } else {
      if (req.session && req.session.xsrf && tokens.verify(req.session.xsrf.secret, tokenHeader)) {
        return {isValid: true, details: 'The request contains a valid x-csrf-token'};
      } else {
        return {isValid: false, details: 'The request contains an invalid x-csrf-token'};
      }
    }
  },

  /**
   * Returns a new token and stores it in the session (or returns an existing one from the session)
   *
   * @param req
   * @param cb function cb(err, token)
   */
  getToken: function (req, cb) {
    if (!req.session) {
      return cb(new Error('No session established. Failed to store token in session'));
    }
    if (!req.session.xsrf) {
      let token;
      let secret;
      try {
        secret = tokens.secretSync();
        token = tokens.create(secret);
      } catch (err) {
        return cb(err);
      }
      sessionExt.update(req.session, function (session) {
        session.xsrf = session.xsrf || {
          token: token,
          secret: secret
        };
      },function (){
        return cb(null, req.session.xsrf.token);
      });
    }
    else {
      return cb(null, req.session.xsrf.token);
    }
  }
};

function hasTokenFetchHeader(req) {
  const tokenHeader = req.headers['x-csrf-token'];
  return ((tokenHeader) ? tokenHeader.toLowerCase() === 'fetch' : false);
}

function isGetRequest(req) {
  return req.method === 'GET';
}

function isHeadRequest(req) {
  return req.method === 'HEAD';
}
