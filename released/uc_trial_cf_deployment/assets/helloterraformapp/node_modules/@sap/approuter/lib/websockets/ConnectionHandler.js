'use strict';

const WebSocket = require('ws');
const Session = require('express-session').Session;
const jwtRefresh = require('../passport/jwt-refresh');

const GENERAL_WS_ERROR_CODE = 1008;

module.exports = ConnectionHandler;

function ConnectionHandler(loggingContext) {
  this.logger = loggingContext.getLogger('/approuter/WebSockets');
  this.tracer = loggingContext.getTracer(__filename);
}

function refreshJWT(req) {
  if (req.session && req.session.user && !req.session.jwtRefreshStarted) {
    jwtRefresh.refreshToken(req.app, req.session);
  }
}

ConnectionHandler.prototype.onOpen = function (incoming, outgoing) {
  let req = incoming.upgradeReq;
  this.memoryStore = req.app.get('memoryStore');
  if (req.session) {
    this.sessionID = req.session.id;
    refreshJWT(req);
  }
  this.incoming = incoming;
  this.outgoing = outgoing;

  if (this.sessionID) {
    let handleSessionEndFn = handleSessionEnd.bind(this);
    req.app.approuter.on('logout', handleSessionEndFn);
    incoming.on('close', function () {
      req.app.approuter.removeListener('logout', handleSessionEndFn);
    });
  }
  incoming.on('error', handleError.bind(this, 'incoming'));
  outgoing.on('error', handleError.bind(this, 'outgoing'));
  let self = this;
  incoming.on('message', function (msg) {
    sendMessage.call(self, outgoing, msg);
    resetSessionTimeout.call(self, req);
  });
  outgoing.on('message', sendMessage.bind(this, incoming));
  incoming.on('close', handleClose.bind(this, 'incoming'));
  outgoing.on('close', handleClose.bind(this, 'outgoing'));
  incoming.on('ping', resetSessionTimeout.bind(this, req));
  incoming.on('pong', handleIncomingPong.bind(this));
  outgoing.on('pong', incoming.pong.bind(incoming));
};

function resetSessionTimeout(req) {
  if (!this.sessionID) {
    return;
  }
  this.memoryStore.resetSessionTimer(this.sessionID);
  if (req.isSessionReloadStarted) {
    return;
  }
  req.isSessionReloadStarted = true;
  if (!isSocketOpen(this.incoming) || !isSocketOpen(this.outgoing)) {
    return;
  }
  this.memoryStore.get(this.sessionID, function (err, sess) {
    req.session = new Session(req, sess);
    refreshJWT(req);
  });
  setTimeout(function () {
    if (req) {
      req.isSessionReloadStarted = false;
    }
  }, 10 * 1000); // 10 seconds
}

function handleSessionEnd(session) {
  if (isSocketOpen(this.incoming) && session.id === this.sessionID) {
    this.tracer.debug('[websockets] session ended, closing incoming socket, session id: %s', session.id);
    this.incoming.close(GENERAL_WS_ERROR_CODE, 'Session ended!');
  }
  this.sessionID = null;
}

function handleIncomingPong(data) {
  resetSessionTimeout.call(this, this.incoming.upgradeReq);
  this.outgoing.pong(data, true, () => {
    return;
  });
}

function handleError(socketType, err) {
  this.logger.error(err, '[websockets] %s connection error occurred', socketType);
  let secondSocket = this[getSecondSocketType(socketType)];
  isSocketOpen(secondSocket) && secondSocket.close(GENERAL_WS_ERROR_CODE, err.message);
}

function sendMessage(socket, msg) {
  if (!isSocketOpen(socket)) {
    return this.logger.error('[websockets] cannot send message! Socket closed!');
  }
  let self = this;
  socket.send(msg, function ack(err) {
    if (err) {
      self.logger.error(err, '[websockets] error during socket.send');
    }
  });
}

function handleClose(socketType, code, message) {
  message = message || (socketType + ' connection closed');
  code = (isValidCode(code) && code) || GENERAL_WS_ERROR_CODE;
  this.tracer.debug('[websockets] %s socket closed: %s, code: %d', socketType, message, code);
  let secondSocket = this[getSecondSocketType(socketType)];
  isSocketOpen(secondSocket) && secondSocket.close(code, message);
}

function isSocketOpen(socket) {
  return !!socket && socket.readyState === WebSocket.OPEN;
}

function isValidCode(code) {
  // the codes are defined in rfc6455#section-7.4
  return !!code && ((code >= 1000 && code <= 1011 && code !== 1004 && code !== 1005 && code !== 1006) ||
    (code >= 3000 && code <= 4999));
}

function getSecondSocketType(socketType) {
  return socketType === 'incoming' ? 'outgoing' : 'incoming';
}
