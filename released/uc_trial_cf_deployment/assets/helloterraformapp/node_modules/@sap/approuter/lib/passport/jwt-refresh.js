'use strict';

const VError = require('verror').VError;
const loggerUtils = require('../utils/logger');
const passportUtils = require('./utils');
const deepmerge = require('deepmerge');

const tracer = loggerUtils.getTracer(__filename);
const logger = loggerUtils.getLogger('/request/uaa');

module.exports = {
  executeAfter: function (fn, timeout) {
    setTimeout(fn, timeout);
  },

  refreshToken: function (app, session) {
    tracer.path('Entering refreshToken');

    let routerConfig = app.get('mainRouterConfig');
    let jwtRefresh = routerConfig.jwtRefresh;
    let tokenRefreshTimestamp = session.user.token.expiryDate - toMilliseconds(jwtRefresh);

    let msBeforeRefresh = tokenRefreshTimestamp - Date.now();
    if (msBeforeRefresh < 0) {
      return tracer.error('jwtRefresh is greater than the the token validity period!');
    }

    let memoryStore = app.get('memoryStore');
    memoryStore.getSessionTimeout(session.id, function (err, sessionTimeout) {
      if (err || Date.now() + toMilliseconds(sessionTimeout) < tokenRefreshTimestamp) {
        return err && tracer.debug(err);
      }

      memoryStore.update(session.id, function (newSession) {
        if (!newSession || newSession.jwtRefreshStarted) {
          return;
        }
        tracer.info('Updating jwtRefreshStarted to true for session %s.', newSession.id);
        newSession.jwtRefreshStarted = true;
        tracer.info('Refreshing jwt for session %s in %dms.', newSession.id, msBeforeRefresh);
        module.exports.executeAfter(function () {
          doRefresh(app, newSession);
        }, msBeforeRefresh);
      }, false);
    });
  }
};

function toMilliseconds(minutes) {
  return minutes * 60 * 1000;
}

function doRefresh(app, session) {
  tracer.path('Entering doRefresh');
  if (!session || !session.user || !session.user.token){
    tracer.info('JWT could not be refreshed, session, session user or session user token is not defined');
    return;
  }
  let oauthOptions = session.user.token.oauthOptions;
  let requestOptions = {
    url: oauthOptions.tokenURL,
    form: {
      'grant_type': 'refresh_token',
      'refresh_token': session.user.token.refreshToken,
      'app_tid': oauthOptions.iasZoneId
    }
  };
  if (oauthOptions.certificate){
    requestOptions.cert = oauthOptions.certificate;
    requestOptions.key  = oauthOptions.key;
    requestOptions.form['client_id'] =  oauthOptions.clientid;
  } else {
    requestOptions.auth = {
      user: oauthOptions.clientid,
      // eslint-disable-next-line camelcase
      pass: oauthOptions.clientsecret
    };
  }
  requestOptions.timeout = session.user.token.expiryDate - Date.now();
  let checkTimeout = function () {
    if (session.user.token.expiryDate - Date.now() < 0) {
      tracer.info('JWT for session %s could not be refreshed!', session.id);
      return new VError('JWT could not be refreshed,it is expired!');
    }
  };
  passportUtils.callUaa(requestOptions, checkTimeout, function (err, uaaResponse) {
    if (err) {
      tracer.warning(err, 'Session %s', session.id);
      return logger.error('Unable to refresh the JWT for session %s , number of attempts done: %d, error: %s', session.id, passportUtils.MAX_ATTEMPTS_NUMBER, err.message);
    }
    if (!uaaResponse.access_token || !uaaResponse.expires_in || !uaaResponse.refresh_token) {
      return logger.error('Bad response from UAA when refreshing JWT - not all JWT fields are present');
    }
    let updatedSession;
    app.get('memoryStore').update(session.id, function updateSession(newSession) {
      if (!newSession) {
        return;
      }
      let options = {
        accessToken: uaaResponse.access_token ? uaaResponse.access_token : uaaResponse.id_token,
        expiresIn: uaaResponse.expires_in,
        refreshToken: uaaResponse.refresh_token,
        scope: uaaResponse.scope,
        oauthOptions: newSession.user.token.oauthOptions
      };
      newSession.user = newSession.user ? deepmerge(newSession.user, passportUtils.getUserProperties(options))
        : passportUtils.getUserProperties(options);
      newSession.jwtRefreshStarted = false;
      updatedSession = newSession;
      tracer.info('Token refreshed!');
    }, false);
    updatedSession && module.exports.refreshToken(app, updatedSession); // schedule next refresh if needed
  });
}
