'use strict';

const VError = require('verror').VError;

const backendOptions = require('../backend-request/options');
const cookieHandler = require('../backend-response/cookie-handler');
const traceUtil = require('../utils/trace-util');
const requestTraceEnabled = traceUtil.requestTraceEnabled;
const businessServiceUtils = require('../utils/business-service-utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');
const applicationLogUtils = require('../utils/application-logs-utils');
const sapStatisticsUtils = require('../utils/sap-statistics-utils');
const headerUtils = require('../utils/header-util');

module.exports = function requestHandler(req, res, next) {
  let logger;
  if (req.loggingContext) {
    logger = req.loggingContext.getLogger('/requestHandler');
  }

  if (!req.internalUrl) {
    if (logger) {
      logger.info('Missing internal url for request url %s', req.url);
    }
    return next();
  }

  const routerConfig = req.routerConfig;
  const serviceTag = req.internalUrl.route.service;
  if (serviceTag && businessServiceUtils.getGrantType(req.internalUrl.route.credentials) === 'user_token'){
    callBackend(req, res, req.session.user.businessServices[serviceTag].accessToken, next);
  } else {
    if (routerConfig.getToken) {
      const startTime = Date.now();
      routerConfig.getToken(req, function (err, accessToken) {
        if (err) {
          return next(err);
        }
        traceGetToken(req.loggingContext, accessToken, startTime);
        callBackend(req, res, accessToken, next);
      });
    } else {
      callBackend(req, res, null, next);
    }
  }
};


function traceGetToken(loggingContext, accessToken, startTime) {
  const tracer = loggingContext.getTracer(__filename);
  const time = Date.now() - startTime;
  if (accessToken) {
    tracer.debug('getToken returned a custom access token in %d ms', time);
  } else {
    tracer.debug('getToken completed in %d ms without a custom access token', time);
  }
}

function callBackend(req, res, accessToken, next) {
  const logger = req.loggingContext.getLogger('/callBackend');
  const logLevel = logger.getLevel();
  const correlationId = headerUtils.getCorrelationId(req);
  const url = req.internalUrl;
  const backendRequest = backendOptions.getRequest(req, accessToken);
  if (sapStatisticsUtils.isSapStatisticsEnabledByRequestHeader(req) === true) {
    sapStatisticsUtils.setTime(sapStatisticsUtils.START_BACKEND, req);
  }
  const requestStats = {};
  let shouldPropagateError = true;
  if (requestTraceEnabled) {
    requestStats.requestStart = Date.now();
  }
  const clientReq = backendRequest();

  if (url.destination.timeout) {
    clientReq.setTimeout(url.destination.timeout);
  }
  clientReq.on('timeout', function () {
    clientReq.abort();
    const options = {
      message :'Request to %s failed with a timeout',
      status:504,
      correlationId,
      logLevel,
      href:url.href
    };
    if (req && req.backendTimeout){
      req.backendTimeout(req,() => {
        returnGateWayError(options, next);
      });
    } else {
      returnGateWayError(options, next);
    }
  });
  clientReq.on('error', function (err) {
    const options = {
      err,
      message :'error while forwarding request to %s',
      status:502,
      correlationId,
      logLevel,
      href:url.href
    };
    if (shouldPropagateError) {
      returnGateWayError(options, next);
    }
  });
  req.on('error', function (err) {
    const options = {
      err,
      message :'error in reading from incoming request while forwarding to %s',
      status:502,
      correlationId,
      logLevel,
      href:url.href
    };
    returnGateWayError(options, next);
  });

  req.on('aborted', function(){
    shouldPropagateError = false;
    clientReq.abort();
  });
  req.pipe(clientReq);

  if (requestTraceEnabled) {
    clientReq.on('socket', function (socket) {
      requestStats.currentBytesRead = socket.bytesRead;
    });
  }
  clientReq.on('response', function(clientRes) {
    const requests = {
      incomingRequest: req,
      incomingResponse: res,
      outgoingRequest: clientReq,
      outgoingResponse: clientRes
    };
    onResponse(requests, requestStats, next);
  });
}

function onResponse(requests, requestStats, next) {
  const incomingRequest = requests.incomingRequest;
  const incomingResponse = requests.incomingResponse;
  const outgoingRequest = requests.outgoingRequest;
  const outgoingResponse = requests.outgoingResponse;
  const tracer = incomingRequest.logger;
  const logger = incomingRequest.loggingContext.getLogger('/request/outgoing');
  const logLevel = logger.getLevel();
  const correlationId = headerUtils.getCorrelationId(incomingRequest);
  traceUtil.traceBackendResponse(tracer, outgoingResponse);
  const backendCookies = cookieHandler.processCookies(outgoingResponse.headers['set-cookie']);
  if (incomingRequest.session && backendCookies.sessionCookies.length > 0) {
    cookieHandler.storeSessionCookies(backendCookies.sessionCookies, incomingRequest, incomingResponse);
  }
  for (let headerName in outgoingResponse.headers) {
    if (headerName === 'set-cookie') {
      const isService2Approuter = incomingRequest.headers && incomingRequest.headers['x-approuter-authorization'];
      const encryptedBackendCookie = incomingResponse.getHeader('set-cookie');
      if (isService2Approuter && encryptedBackendCookie){
        tracer.debug('concatenating backend encrypted cookie');
        backendCookies.nonSessionCookies.length && incomingResponse.setHeader(headerName, backendCookies.nonSessionCookies.concat(encryptedBackendCookie));
      } else {
        tracer.debug('sending non session backend cookies');
        backendCookies.nonSessionCookies.length && incomingResponse.setHeader(headerName, backendCookies.nonSessionCookies);
      }
    } else if (headerName === 'content-security-policy' && process.env.MERGE_CSP_HEADERS && incomingResponse.getHeader(headerName)){
      incomingResponse.setHeader(headerName,[incomingResponse.getHeader(headerName),outgoingResponse.headers[headerName]]);
    } else {
      incomingResponse.setHeader(headerName, outgoingResponse.headers[headerName]);
    }
  }

  if (sapStatisticsUtils.isSapStatisticsEnabledByRequestHeader(incomingRequest) === true) {
    sapStatisticsUtils.setTime(sapStatisticsUtils.END_TOTAL, incomingRequest);
    incomingResponse.setHeader('sap-statistics-approuter', sapStatisticsUtils.getSapStatisticsResponseHeaderValue(incomingRequest));
  }

  attachCacheBusterHeaders(incomingRequest,incomingResponse);
  const url = incomingRequest.internalUrl;
  if (outgoingResponse.statusCode < 100 || outgoingResponse.statusCode > 999){
    let message = 'Invalid status code: %d returned from backend request to %s';
    if (!outgoingResponse.statusCode){
      message = 'No statusCode returned from backend request to %s';
    }
    const options = {
      message :message,
      status:500,
      backendStatus :outgoingResponse.statusCode,
      correlationId,
      logLevel,
      href:url.href
    };
    returnGateWayError(options,next);
    outgoingResponse.statusCode = 500;
  }
  incomingResponse.statusCode = outgoingResponse.statusCode;
  incomingResponse.statusMessage = outgoingResponse.statusMessage;

  handleBackendError(incomingRequest, incomingResponse);
  if (url.destination.timeout) {
    outgoingResponse.setTimeout(url.destination.timeout);
  }
  outgoingResponse.on('timeout', function() {
    outgoingRequest.abort();
    const options = {
      message :'Response from %s failed with a timeout',
      status:504,
      correlationId,
      logLevel,
      href:url.href
    };
    returnGateWayError(options, next);
  });
  outgoingResponse.on('error', function(err) {
    const options = {
      err,
      message :'error while reading from incoming response (backend request to %s)',
      status:502,
      correlationId,
      logLevel,
      href:url.href
    };
    returnGateWayError(options, next);
  });
  if (requestTraceEnabled) {
    outgoingResponse.on('end', function () {
      if (outgoingResponse.connection) {
        const bytesRead = outgoingResponse.connection.bytesRead - requestStats.currentBytesRead;
        logger.info('%s to %s took %d ms to respond with status code %d and %d bytes',
          incomingRequest.method, url.href, Date.now() - requestStats.requestStart, outgoingResponse.statusCode, bytesRead);
      }
    });
  }
  incomingResponse.on('error', function(err) {
    const options = {
      err,
      message :'error while sending data to outgoing response (backend request to %s)',
      status:502,
      correlationId,
      logLevel,
      href:url.href
    };
    returnGateWayError(options,next);
  });
  traceUtil.traceOutgoingResponse(tracer, incomingResponse);
  if (incomingRequest.afterRequestHandler) {
    incomingRequest.afterRequestHandler({
      incomingRequest : incomingRequest,
      incomingResponse: incomingResponse,
      outgoingRequest : outgoingRequest,
      outgoingResponse: outgoingResponse
    }, (err, incomingResponse) => {
      if (err){
        logger.error('Error %s occurred in afterRequestHandler extension for request url %s', err, incomingRequest.url);
      }
      outgoingResponse.pipe(incomingResponse);
    });
  }
  else {
    outgoingResponse.pipe(incomingResponse);
  }
}

function returnGateWayError(options, next) {
  const { err ,message ,status ,backendStatus ,correlationId ,logLevel ,href } = options;
  let error;
  if (err){
    error = new VError(err, message, href);
  } else if (backendStatus){
    error = new VError(message,backendStatus, href);
  } else {
    error = new VError(message, href);
  }

  if (logLevel ===  'error'){
    error.stack = null;
  }
  error.message += ` correlation_id = ${correlationId}`;
  error.status = status;
  next(error);
}
function attachCacheBusterHeaders(req,res){
  const cacheControlHeader = res.getHeaders() && res.getHeaders()['cache-control'];
  if (!cacheControlHeader && dynamicRoutingUtils.isDynamicRouting() && req.internalUrl &&
      req.internalUrl.route &&
      dynamicRoutingUtils.isHtml5RepoService(req.internalUrl.route.service) &&
      dynamicRoutingUtils.getCacheBusterToken(req)){
    res.setHeader('Cache-Control', ['public','max-age=31536000']);
  }
}
function handleBackendError(incomingRequest, incommingResponse){
  if (incommingResponse.statusCode > 399 && incommingResponse.statusCode < 600){
    const errorMessage = incomingRequest.method + ' request to ' + incomingRequest.internalUrl.href + ' completed with status ' + incommingResponse.statusCode +
      ' ' + incommingResponse.statusMessage + ' check backend application logs';
    applicationLogUtils.logRequestWarning(incomingRequest, errorMessage);
  }
}

module.exports.returnGateWayError = returnGateWayError;
