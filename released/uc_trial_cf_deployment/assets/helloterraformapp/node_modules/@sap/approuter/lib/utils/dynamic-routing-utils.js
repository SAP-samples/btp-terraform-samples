'use strict';

const SAAS_REGISTRY = 'saas-registry';
const SUBSCRIPTION_MANAGER = 'subscription-manager';
const request = require('./request-utils');
const NodeCache = require('node-cache');
const businessServiceUtils = require('./business-service-utils');
const tracer = require('./logger').getTracer(__filename);
const requestTraceEnabled = require('../utils/trace-util').requestTraceEnabled;
const tokenUtils = require('../utils/token-utils');
const headerUtils = require('../utils/header-util');
const configurationUtils = require('../../lib/utils/configuration-utils');
const html5RepoService = 'html5-apps-repo-rt';
const applicationLogUtils = require('./application-logs-utils');
const urlUtils = require('../utils/url-utils');
const fs = require('fs');
const passportUtils = require('../passport/utils');
const vcapUtils = require('../utils/vcap-utils');
const subscriptionUtils = require('../utils/subscription-utils');
const html5RepoUtils = require('../utils/html5-repo-utils');

let ar;
let configCache;

exports.getRemoteConfiguration = getRemoteConfiguration;
exports.isDynamicRouting = isDynamicRouting;
exports.initialize = initialize;
exports.getRemoteConfigurationOptions = getRemoteConfigurationOptions;
exports.getRouterConfig = getRouterConfig;
exports.getApplicationKey = getApplicationKey;
exports.isHTML5RepoExcludedApp = isHTML5RepoExcludedApp;
exports.getCoreUrl = getCoreUrl;
exports.getFullPathWithoutPrefix = getFullPathWithoutPrefix;
exports.getFullUrl = getFullUrl;
exports.getCacheBusterToken = getCacheBusterToken;
exports.isHtml5RepoService = isHtml5RepoService;


function getRouterConfig(req, callback) {
  let routerConfig;
  if (req.dynamicRouting && req.dynamicRouting.routerConfig) {
    routerConfig = req.dynamicRouting.routerConfig;
  }
  callback(null, routerConfig);
}

function getRemoteConfiguration(req, res, next) {
  const appKey = getApplicationKey(req);
  if (!appKey) {
    return next();
  }

  if (process.env.SAAS_APPROUTER) {
    applicationLogUtils.logRequestSetTenant(req, req.tenant + '-' + appKey.appName);
  }

  const actualKey = appKey.bsKey || appKey;

  if (isHTML5RepoExcludedApp(actualKey, req)) {
    req.dynamicRouting = {appKey: null};
    return next();
  }

  getConfigurations(req, actualKey, function (err, configuration) {
    if (err) {
      return next(err);
    } else {
      let options = {
        xsappConfig: configuration ? configuration.xsapp : 'xs-app.json',
        xsappname: configuration ? configuration.xsappname : null
      };
      storeLogoutDataOnRequest(req, configuration);
      ar.createRouterConfig(options, function (err, routerConfig) {
        if (err) {
          return next(err);
        } else {
          req.dynamicRouting = {routerConfig: routerConfig, appKey: (configuration ? appKey : null)};
          return next();
        }
      });
    }
  });
}

function getRemoteConfigurationOptions(req, callback) {
  let appKey = getApplicationKey(req);
  if (!appKey) {
    return callback(null);
  }

  if (!configCache) { // initialize is not called in case of extentions
    configCache = new NodeCache({stdTTL: 300, checkperiod: 320});
  }

  getConfigurations(req, (appKey.bsKey || appKey), function (err, configuration) {
    if (err) {
      return callback(err);
    } else {
      let options = {
        xsappConfig: configuration ? configuration.xsapp : 'xs-app.json',
        destinations: configuration ? configuration.destinations : null,
        xsappname: configuration ? configuration.xsappname : null
      };
      return callback(null, options);
    }
  });
}

function getConfigurations(req, appKey, callback) {
  let config = configCache.get(appKey.entireKey);
  const skipCacheParam = 'skipXSAppJsonCache';

  let skipCacheParamValue = urlUtils.getQueryParam(req, skipCacheParam);
  let skipXSAppJsonCache = skipCacheParamValue !== null && typeof (skipCacheParamValue) !== 'undefined';

  if (config && !skipXSAppJsonCache) {
    return callback(null, config);
  }

  if (skipXSAppJsonCache) {
    req.url = urlUtils.removeQueryParam(req, skipCacheParam);
  }

  getVcapServicesData(req, appKey, function (err, vcapServicesData) {
    if (err) {
      return callback(err);
    } else if (!vcapServicesData) {
      return callback(null, null);
    }
    request.get(vcapServicesData.requestOptions, function onResponse(err, res, body) {
      if (err || !res || !res.statusCode) {
        return callback('Error while retrieving xsApp configuration ' + err);
      } else if (res.statusCode === 404) {
        return callback('Application does not have xs-app.json');
      } else if (res.statusCode === 503) {
        tracer.info('Application %s does not exist', appKey.entireKey);
        if (process.env.SAAS_APPROUTER) {
          applicationLogUtils.logRequestSetTenant(req, req.tenant);
        }
        return callback(null, null);
      } else if (res.statusCode === 403) {
        let message = appKey.appPrefix ? 'Unauthorized. Please check with the business service \'' + appKey.appPrefix + '\' provider if the requested UI is defined as public' :
          'Unauthorized. Probably html5 apps repo rejected the token';
        return callback(message);
      } else if (res.statusCode === 400) {
        if (vcapServicesData.requestOptions && vcapServicesData.requestOptions.headers['x-app-host-id']) {
          let appHostID = vcapServicesData.requestOptions.headers['x-app-host-id'];
          return callback('Application configuration is not valid. Invalid App Host ID - ' + appHostID + '. Please check with business service \'' + appKey.appPrefix + '\' provider if the requested App Host ID is valid');
        }
        return callback('Application configuration is not valid. Invalid App Host ID. Please check with business service \'' + appKey.appPrefix + '\' provider if the requested App Host ID is valid');
      } else if (res.statusCode !== 200) {
        return callback('Error while retrieving xsApp configuration, response code ' + res.statusCode);
      }
      try {
        config = {};
        config.xsapp = JSON.parse(body);
      } catch (e) {
        return callback(`xs-app.json file from application ${appKey.entireKey} contains an invalid json. Error: ${e.message}`);
      }
      if (vcapServicesData.xsappname) {
        config.xsappname = vcapServicesData.xsappname;
      }
      let success = configCache.set(appKey.entireKey, config);
      if (!success) {
        return callback('Failed to set configuration cache');
      }
      callback(null, config);
    });
  });
}

function storeLogoutDataOnRequest(req, configuration) {
  const routerConfigServices = req.app && req.app._store && req.app._store.mainRouterConfig && req.app._store.mainRouterConfig.appConfig
  && req.app._store.mainRouterConfig.appConfig.services ? req.app._store.mainRouterConfig.appConfig.services : null;
  const xsappDestinations =  configuration && configuration.xsapp && configuration.xsapp.destinations;
  const xsappServices =  configuration && configuration.xsapp && configuration.xsapp.services;
  if (!xsappDestinations && !xsappServices && !routerConfigServices) {
    return;
  }
  req.toBeCachedOnSession = req.toBeCachedOnSession ? req.toBeCachedOnSession : {};
  req.toBeCachedOnSession.user = req.toBeCachedOnSession.user ? req.toBeCachedOnSession.user : {};
  req.toBeCachedOnSession.user.logout = {};

  const approuterHost = req.headers.host ? req.headers.host : null;

  if (xsappDestinations) {
    req.toBeCachedOnSession.user.logout.destinations = xsappDestinations;
  }
  if (xsappServices || routerConfigServices) {
    req.toBeCachedOnSession.user.logout.services = {};
    let servicesNames;
    let serviceName;
    let i;
    if (routerConfigServices && process.env.SAAS_APPROUTER) {
      servicesNames = Object.keys(routerConfigServices);
      for (i = 0; i < servicesNames.length; i++) {
        serviceName = servicesNames[i];
        req.toBeCachedOnSession.user.logout.services[serviceName] =
            Object.assign({approuterHost: approuterHost}, routerConfigServices[serviceName]);
      }
    }
    if (xsappServices) {
      servicesNames = Object.keys(xsappServices);
      for (i = 0; i < servicesNames.length; i++) {
        serviceName = servicesNames[i];
        req.toBeCachedOnSession.user.logout.services[serviceName] =
            Object.assign({approuterHost: approuterHost}, xsappServices[serviceName]);
      }
    }
  }
}

function getVcapServicesData(req, appKey, cb) {

  let bsCredentials;

  if (!req.app) {
    return cb('Missing req.app');
  }
  let html5RepoCredentials = businessServiceUtils.getCredentials('html5-apps-repo-rt', false, req);

  if (!html5RepoCredentials) {
    return cb('Error during loading of html5-apps-repo-rt credentials. ' +
        'Verify html5-apps-repo service with plan app-runtime is bound');
  }

  if (!html5RepoCredentials.uri) {
    return cb('Invalid credentials for html5-apps-repo service with plan app-runtime');
  }

  html5RepoCredentials.label = 'html5-apps-repo-rt';

  getHTML5RepoToken(req, html5RepoCredentials, function (err, html5RepoToken) {
    const logger  = req.loggingContext.getLogger('/Dynamic routing');
    if (err) {
      return cb(err);
    }
    if (appKey && appKey.appPrefix) {
      bsCredentials = businessServiceUtils.getCredentials(appKey.appPrefix, true, req);

      if (!bsCredentials) {
        logger.warning('Service Tag %s is unknown', appKey.appPrefix);
        return cb(null, null);
      }

      if (!bsCredentials || !bsCredentials['html5-apps-repo']) {
        return cb('Invalid VCAP credentials for business service: html5-apps-repo part is missing');
      }
      if (!bsCredentials['html5-apps-repo']['app_host_id']) {
        return cb('Invalid VCAP credentials for business service: app_host_id is missing');
      }
    }

    let vcapServicesData = {};
    let requestOptions = {};

    requestOptions.url = html5RepoCredentials.uri + '/' + appKey.appKeyWithoutPrefix + '/xs-app.json';
    requestOptions.headers = {};
    requestOptions.headers.accept = 'application/json;charset=utf-8';
    requestOptions.headers.authorization = 'Bearer ' + html5RepoToken.accessToken;

    if (bsCredentials) {
      if (bsCredentials['html5-apps-repo'] && bsCredentials['html5-apps-repo']['app_host_id']) {
        requestOptions.headers['x-app-host-id'] = bsCredentials['html5-apps-repo']['app_host_id'];
      }
      if (bsCredentials['uaa'] && bsCredentials['uaa']['xsappname']) {
        vcapServicesData.xsappname = bsCredentials['uaa']['xsappname'];
      } else {
        logger.warning('\'xsappname\' property not found in business service - UAA configuration');
      }
    }
    vcapServicesData.requestOptions = requestOptions;

    cb(null, vcapServicesData);
  });
}

function getCacheBusterToken(req) {
  const tokenRegEx = /^~(.*)~$/;
  const segments = req.url.split('/');
  if (tokenRegEx.test(segments[2])) {
    return segments[2];
  }
  if (segments[3] && tokenRegEx.test(segments[3])) {
    return segments[3];
  }
  return null;
}

function getApplicationKey(req,segmentIndex) {
  const appKey = {};
  let parts;
  const appNameRegex = new RegExp('^[a-zA-Z0-9_ ]+$');

  if (req.dynamicRouting && req.dynamicRouting.hasOwnProperty('appKey')) {
    return req.dynamicRouting.appKey;
  }

  const pathSegments = req.url.split('/');
  appKey.entireKey = pathSegments[segmentIndex || 1];

  if (requestTraceEnabled) {
    tracer.info('Application key = %s', appKey.entireKey);
  }
  // eslint-disable-next-line quotes
  if (!appKey.entireKey || appKey.entireKey === '' || appKey.entireKey.indexOf('?') > -1) {
    return null;
  }

  let appVersionRegex = new RegExp('-(\\d+\\.){2}(\\d+)$');
  let match = appKey.entireKey.match(appVersionRegex);
  if (match && match[0]) {
    appKey.appVersion = match[0].slice(1);
    appKey.appName = appKey.entireKey.replace(match[0], '');
  } else {
    appKey.appVersion = null;
    appKey.appName = appKey.entireKey;
  }

  parts = appKey.appName.split('.');
  if (!parts || parts.length < 2) {
    appKey.appPrefix = null;
  } else if (parts.length === 3 && process.env.SAAS_APPROUTER) {
    appKey.appDestinationId = urlUtils.addUUIDDashes(parts[0]);
    appKey.appPrefix = parts[1];
    appKey.appNameWithoutPrefix = parts[2];
  } else {
    appKey.appPrefix = parts[0];
    appKey.appNameWithoutPrefix = parts[1];
  }

  if (!appKey.appNameWithoutPrefix) {
    appKey.appNameWithoutPrefix = appKey.appName;
  }

  if (appKey.appVersion) {
    appKey.appKeyWithoutPrefix = appKey.appNameWithoutPrefix + '-' + appKey.appVersion;
  } else {
    appKey.appKeyWithoutPrefix = appKey.appNameWithoutPrefix;
  }

  if (appKey && appNameRegex.test(appKey.appNameWithoutPrefix)){
    if (process.env.SAAS_APPROUTER && !segmentIndex){
      const bsKey = pathSegments[2] && exports.getApplicationKey(req,2);
      html5RepoUtils.attachCredentials(appKey.appPrefix, (bsKey && bsKey.appPrefix),appKey.appDestinationId, req);
      appKey.bsKey = bsKey && bsKey.appPrefix && html5RepoUtils.getCredentials(bsKey.appPrefix,req) ? bsKey : undefined;
    }
    return appKey;
  } else {
    return null;
  }
}

function isDynamicRouting() {
  let html5RepoCredentials = businessServiceUtils.getCredentials('html5-apps-repo-rt', false);
  if (html5RepoCredentials) {
    return true;
  }
  if (process.env.NODE_ENV === 'development' && fs.existsSync('default-env.json')) {
    try {
      let defaultEnvJson = JSON.parse(fs.readFileSync('default-env.json', 'utf8'));
      return defaultEnvJson['VCAP_SERVICES'] && defaultEnvJson['VCAP_SERVICES']['html5-apps-repo'];
    } catch (err) {
      tracer.error('Failed to parse default-env.json', err);
    }
  }
  return false;
}

function isHtml5RepoService(service) {
  return service === 'html5-apps-repo-rt';
}

function initialize(approuter) {
  ar = approuter;
  configCache = new NodeCache({stdTTL: 300, checkperiod: 320});
  return getRemoteConfiguration;
}

function getCoreUrl(req) {
  if (!isDynamicRouting()) {
    return req.url;
  }
  let appKey = getApplicationKey(req);
  if (!appKey) {
    return req.url;
  } else {
    let urlAfterReplace = req.url.replace('/' + appKey.entireKey, '');
    if (appKey.bsKey) {
      urlAfterReplace = urlAfterReplace.replace('/' + appKey.bsKey.entireKey, '');
    }
    let cacheBusterToken = getCacheBusterToken(req);
    urlAfterReplace = (cacheBusterToken) ? urlAfterReplace.replace('/' + cacheBusterToken, '') : urlAfterReplace;
    return (urlAfterReplace ? urlAfterReplace : '/');
  }
}

function getFullPathWithoutPrefix(req, path) {
  if (!isDynamicRouting()) {
    return path;
  }

  let appKey = getApplicationKey(req);
  if (!appKey) {
    return path;
  } else {
    return '/' + (appKey.bsKey && appKey.bsKey.appKeyWithoutPrefix || appKey.appKeyWithoutPrefix) + path;
  }
}

function getFullUrl(req, url) {
  if (!isDynamicRouting()) {
    return url;
  }

  let appKey = getApplicationKey(req);
  if (!appKey) {
    return url;
  } else {
    return '/' + (appKey.bsKey && appKey.bsKey.entireKey || appKey.entireKey) + url;
  }
}

function getHTML5RepoToken(req, html5RepoCredentials, cb) {
  let tenant = passportUtils.getUrlTenant(req);
  if (tenant && html5RepoCredentials.saasregistryenabled) {
    return fetchSubscriberSubaccountToken(req, tenant, html5RepoCredentials, cb);
  } else {
    return fetchProviderSubaccountToken(req, html5RepoCredentials, cb);
  }
}

function isHTML5RepoExcludedApp(appKey, req) {
  let currentAsRegex;
  let configDirectRoutingUriPatterns;
  let directRoutingUriPatterns = ['^favicon.ico$', '^login$'];

  let saasRegistryCredentials = vcapUtils.getServiceCredentials({label: SAAS_REGISTRY});
  let smsCredentials = vcapUtils.getServiceCredentials({label: SUBSCRIPTION_MANAGER});
  if (subscriptionUtils.getSubscriptionProcessType(req, saasRegistryCredentials, smsCredentials) !== null) {
    return true;
  }

  try {
    if (process.env.DIRECT_ROUTING_URI_PATTERNS) {
      configDirectRoutingUriPatterns = JSON.parse(process.env.DIRECT_ROUTING_URI_PATTERNS);
      directRoutingUriPatterns = Array.prototype.concat(directRoutingUriPatterns, configDirectRoutingUriPatterns);
    }

    for (let i = 0; i < directRoutingUriPatterns.length; i++) {
      // if current configured "direct routing uri pattern" is a string
      if (appKey.entireKey === directRoutingUriPatterns[i]) {
        return true;
      } else {
        // if current configured "direct routing uri pattern" is a regex
        currentAsRegex = configurationUtils.constructRegExp(directRoutingUriPatterns[i]);
        if (currentAsRegex.test(appKey.entireKey)) {
          return true;
        }
      }

    }

    return false;
  } catch (e) {
    throw (new Error('Failed to parse or process direct routing uri patterns ' + e));
  }
}

function fetchProviderSubaccountToken(req, html5RepoCredentials, cb) {
  if (!req.app.services || !req.app.services[html5RepoService]
      || !req.app.services[html5RepoService].token || req.app.services[html5RepoService].token.tokenRefreshTimestamp - Date.now() <= 0) {
    tokenUtils.loadClientCredentialsToken(req.app, headerUtils.getCorrelationId(req), html5RepoCredentials, html5RepoService, function (err) {
      let token = !err ? req.app.services[html5RepoService].token : null;
      return cb(err, token);
    });
  } else {
    cb(null, req.app.services[html5RepoService].token);
  }
}

function fetchSubscriberSubaccountToken(req, tenant, html5RepoCredentials, cb) {
  if (req.app.services && req.app.services[html5RepoService] && req.app.services[html5RepoService][tenant]
      && req.app.services[html5RepoService][tenant].token
      && req.app.services[html5RepoService][tenant].token.tokenRefreshTimestamp - Date.now() > 0) {
    return cb(null, req.app.services[html5RepoService][tenant].token);
  } else {
    const logger  = req.loggingContext.getLogger('/Dynamic routing');
    tokenUtils.getClientCredentialsTokenByTenant(headerUtils.getCorrelationId(req), tenant, html5RepoCredentials, req.zoneInfo, (err, token) => {
      if (err) {
        let message = 'Could not get html5 repo token from subscriber subaccount ' + tenant + ' fetching from provider subaccount ' + err;
        logger.info(message);
        return fetchProviderSubaccountToken(req, html5RepoCredentials, cb);
      }
      req.app.services[html5RepoService][tenant] = {token: token};
      return cb(null, token);
    });
  }
}