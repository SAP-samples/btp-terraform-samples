'use strict';

const loggingUtils = require('./logger');
const logger = loggingUtils.getLogger('/Subscription');
const urlUtils = require('../utils/url-utils');
const vcapUtils = require('../utils/vcap-utils');
const configUtils = require('../utils/configuration-utils');
const headerUtils = require('../utils/header-util');
const xsenv = require('@sap/xsenv');
const xssec = require('@sap/xssec');
const uaaUtils = require('./uaa-utils');
const iasUtils = require('./ias-utils');
const urijs = require('urijs');
const pki = require('node-forge').pki;
const bsUtils = require('../utils/business-service-utils');
const tracer = require('../utils/logger').getTracer(__filename);
const html5RepoUtils = require('../utils/html5-repo-utils');

const sapCloudServiceParam = 'sap.cloud.service';
const applicationPathParam = 'application.path';
const PROCESS_TYPE_SAAS_REG_GET_DEPENDENCIES     = 'saasRegistryGetDependencies';
const PROCESS_TYPE_SAAS_REG_ON_SUBSCRIPTION      = 'saasRegistryOnSubscription';
const PROCESS_TYPE_SAAS_REG_ON_DEL_SUBSCRIPTION  = 'saasRegistryOnDeleteSubscription';
const PROCESS_TYPE_SMS_GET_DEPENDENCIES          = 'smsGetDependencies';
const PROCESS_TYPE_SMS_ON_SUBSCRIPTION           = 'smsOnSubscription';
const PROCESS_TYPE_SMS_ON_DEL_SUBSCRIPTION       = 'smsOnDeleteSubscription';

exports.getSaaSRegistryDependencies = getSaaSRegistryDependencies;
exports.getSMSDependencies = getSMSDependencies;
exports.checkScopes = checkScopes;
exports.checkCertificate = checkCertificate;
exports.getSaaSRegistryApplicationUrl = getSaaSRegistryApplicationUrl;
exports.getSMSApplicationUrl = getSMSApplicationUrl;
exports.getError = getError;
exports.getSubscriptionProcessType = getSubscriptionProcessType;
exports.getSaaSRegistryCallbackPath = getSaaSRegistryCallbackPath;
exports.getSMSCallbackPath = getSMSCallbackPath;

function getSubscriptionProcessType(req, saasRegistryCredentials, smsCredentials) {
  if (!saasRegistryCredentials && !smsCredentials) {
    return null;
  }
  if (smsCredentials) {
    let callBackPath = getSMSCallbackPath(smsCredentials);
    if (callBackPath.getDependenciesPrefix !== '' && req.url.startsWith(callBackPath.getDependenciesPrefix) && req.method === 'GET') {
      return PROCESS_TYPE_SMS_GET_DEPENDENCIES;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'PUT') {
      return PROCESS_TYPE_SMS_ON_SUBSCRIPTION;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'DELETE') {
      return PROCESS_TYPE_SMS_ON_DEL_SUBSCRIPTION;
    }
  }
  if (saasRegistryCredentials) {
    let callBackPath = getSaaSRegistryCallbackPath(saasRegistryCredentials);
    if (callBackPath.getDependenciesPath !== '' && req.url.startsWith(callBackPath.getDependenciesPath) && req.method === 'GET') {
      return PROCESS_TYPE_SAAS_REG_GET_DEPENDENCIES;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'PUT') {
      return PROCESS_TYPE_SAAS_REG_ON_SUBSCRIPTION;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'DELETE') {
      return PROCESS_TYPE_SAAS_REG_ON_DEL_SUBSCRIPTION;
    }
  }
  return null;
}

function checkScopes(req, cb){
  let sapCloudService = urlUtils.getQueryParam(req,sapCloudServiceParam);
  let ownCredentials = null;
  let token = null;
  try {
    token = getToken(req);
  } catch (err){
    return cb(err);
  }
  if (sapCloudService) {
    bsUtils.getDestinationCredentialsBySapCloudService(req,sapCloudService, (err, result) => {
      if (err) {
        return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService + ' ' + err);
      }
      if (!result){
        html5RepoUtils.attachCredentials(sapCloudService,null,null, req);
        result = html5RepoUtils.getCredentials(sapCloudService, req);
      }
      if (!result){
        return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService);
      }
      ownCredentials = result.uaa || result.credentials.uaa;
      doCheckToken(req, token, ownCredentials,cb);
    });
  } else {
    ownCredentials = xsenv.serviceCredentials({label: 'xsuaa'});
    doCheckToken(req, token, ownCredentials,cb);
  }
}

function checkCertificate(req,credentials, cb){
  let message;
  let clientCertificate = req.headers[process.env.CLIENT_CERTIFICATE_HEADER_NAME || 'x-forwarded-client-cert'];
  if (!clientCertificate){
    message = 'Missing certificate for subscription manager callback in SMS subscription';
    let error = getError(message, 401);
    return cb(error);
  }

  if (!credentials.callback_certificate_subject){
    message = 'Missing certificate subject for subscription manager callback in the call to create subscription';
    let error = getError(message, 401);
    return cb(error);
  }

  let subj;
  try {
    subj = typeof credentials.callback_certificate_subject === 'string' ?
      JSON.parse(credentials.callback_certificate_subject) : credentials.callback_certificate_subject;
  } catch (err){
    message = 'failed to parse certificate subject in SMS subscription';
    return cb(getError(message + ' ' + err, 500));
  }

  clientCertificate = decodeURIComponent(clientCertificate);
  const certStr = (clientCertificate.indexOf('CERTIFICATE') === -1) ? '-----BEGIN CERTIFICATE-----\n' + clientCertificate + '\n-----END CERTIFICATE-----' : clientCertificate;
  let crt;
  try {
    crt = pki.certificateFromPem(certStr);
  } catch (err){
    message = 'Failed to parse certificate';
    return cb(getError(message + ' ' + err, 500));
  }

  const certCN = crt.subject.getField('CN').value;
  const certL = crt.subject.getField('L').value;
  const certOUN = crt.subject.attributes.filter((item) => item.shortName === 'OU').map((item) => { return item.value; });
  const certON = crt.subject.getField('O').value;
  const certC = crt.subject.getField('C').value;

  if (certCN !== subj.CN) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid common name ' + certCN;
    return cb(getError(message, 403));
  }
  if (certL !== subj.L) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid locality name ' + certL ;
    return cb(getError(message, 403));
  }
  if (certON !== subj.O) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid organization name ' + certON;
    return cb(getError(message, 403));
  }
  if (certC !== subj.C) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid country name ' + certC ;
    return cb(getError(message, 403));
  }

  const oun1 = certOUN.sort();
  const oun2 = subj.OU;

  if (!Array.isArray(oun1) &&
      Array.isArray(oun2) &&
      oun1.length === oun2.length &&
      oun1.every((val, index) => val === oun2[index])){
    message = 'Error - failed to validate certificate in SMS subscription, invalid organization unit names ' + certOUN ;
    return cb(getError(message, 403));
  }
  cb();
}

function findCallbackScope(ctx){
  if (process.env.SAAS_APPROUTER){
    return true;
  } else {
    return ctx.checkLocalScope('Callback');
  }
}

function getToken (req){
  const authorization = req.headers.authorization;
  if (!authorization) {
    throw getError('Missing Authorization header', 401);
  }
  const parts = authorization.split(' ');
  if (parts.length < 2) {
    throw getError('Invalid Authorization header format', 400);
  }
  const scheme = parts[0];
  const token = parts[1];

  if (scheme.toLowerCase() !== 'bearer') {
    throw getError('Authorization header is not a Bearer token', 401);
  }
  return token;
}

function getSMSApplicationUrl(req,smsCredentials, cb){
  if (!req.body){
    let error = getError('Bad request: Missing body', 400);
    return cb(error);
  }

  iasUtils.getIasConfig(req, function (err, iasOptions) {
    if (err) {
      return cb(err);
    }
    if (!iasOptions) {
      return cb('Invalid ias options');
    }
    let approuterHost = urlUtils.getRedirectHost(req).replace('.cert.','.');
    let providerTenant = getTenant(approuterHost);
    approuterHost =  approuterHost.replace(providerTenant, req.body.subscriber.subaccountSubdomain);
    let proto = req.headers['x-forwarded-proto'] || req.protocol;
    const response = {
      applicationURL: proto + '://' + approuterHost
    };
    cb(null, response);
  });
}


function getSaaSRegistryApplicationUrl(req,cb){
  let error = null;
  if (!req.body){
    error = getError('Bad request: Missing body', 400);
    return cb(error);
  }

  const subdomain = req.body.subscribedSubdomain;
  if (!subdomain) {
    error = getError('Bad request: Missing subscribedSubdomain', 400);
    return cb(error);
  }

  uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
    if (err) {
      return cb(err);
    }
    if (!uaaOptions) {
      return cb('Invalid UAA options');
    }

    if (uaaOptions.tenantmode !== 'shared'){
      error = getError('Tenant mode should be shared', 500);
      return cb(error);
    }
    const proto = req.headers['x-forwarded-proto'] || req.protocol;
    const url = proto + '://' + urlUtils.getRedirectHost(req).replace(uaaOptions.tenant, subdomain);
    const applicationPath = urlUtils.getQueryParam(req,applicationPathParam);
    const sapCloudService = urlUtils.getQueryParam(req,sapCloudServiceParam);
    if (process.env.SAAS_APPROUTER && applicationPath) {
      if (!sapCloudService) {
        return cb(null,urlUtils.join(url,applicationPath));
      }
      bsUtils.getDestinationCredentialsBySapCloudService(req,sapCloudService, (err, result) => {
        if (err) {
          return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService + ' ' + err);
        }
        if (result){
          return cb(null, result.credentials && result.credentials.destinationId && !applicationPath.startsWith('/') ? urlUtils.join(url,result.credentials.destinationId)
              + '.' + sapCloudService + '.' + applicationPath : urlUtils.join(url,applicationPath));
        }
        html5RepoUtils.attachCredentials(sapCloudService,null,null, req);
        result = html5RepoUtils.getCredentials(sapCloudService, req);
        if (result){
          return cb(null, !applicationPath.startsWith('/') ? urlUtils.join(url,(sapCloudService + '.' + applicationPath))
            : urlUtils.join(url,applicationPath));
        }
        return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService);
      });
    } else {
      cb(null, url);
    }
  });
}

function getError(errorStr, status){
  const error = new Error(errorStr);
  error.status = status;
  return error;
}
function getSMSDependencies(req,cb){
  let uaaCredentials = vcapUtils.getServiceCredentials({ label: 'xsuaa' });
  if (!uaaCredentials) {
    return exports.getSaaSRegistryDependencies(req, cb);
  } else {
    exports.getSaaSRegistryDependencies(req, (err, dependencies) => { // NOT REALLY NEEDED IF ONLY UAA returned
      if (err) {
        return cb(err);
      }
      tracer.info('uaaCredentials: %s', JSON.stringify({
        xsappname: uaaCredentials.xsappname
      }));
      dependencies.push({
        xsappname: uaaCredentials.xsappname
      });

      return cb(null,dependencies);
    });
  }
}

function getSaaSRegistryDependencies(req, cb){
  const sapCloudService = urlUtils.getQueryParam(req,sapCloudServiceParam);
  if (process.env.SAAS_APPROUTER && sapCloudService){
    return getSaaSRegistryDependenciesBySapCloudService(sapCloudService,req,cb);
  }
  const dependenciesArray = [];
  let appId = null;
  let appName = null;
  let xsappname = null;
  let services = xsenv.readServices();
  for (const service in services) {
    xsappname = appId = appName = null;
    const svcName = services[service].label;
    const cred = services[service].credentials;

    if (svcName === 'destination' || svcName === 'connectivity' || (svcName === 'auditlog' && services[service].plan === 'oauth2')) {
      appId = cred.xsappname || cred.uaa.xsappname;
      appName = svcName;
    } else if (cred.saasregistryappname){
      appId = cred.uaa.xsappname;
      appName = cred.saasregistryappname;
    } else if (cred.saasregistryenabled){
      xsappname = cred.xsappname || cred.uaa.xsappname;
    }
    let obj = null;
    if (appId && appName) {
      obj = {'appId': appId, 'appName': appName};
    } else if (xsappname){
      obj = {'xsappname': xsappname};
    }
    if (obj){
      dependenciesArray.push(obj);
    }
  }
  tracer.info('dependencies array returned from subscription-utils: %s', JSON.stringify(dependenciesArray));
  cb(null,dependenciesArray);
}

function getSaaSRegistryCallbackPath(credentials){
  const callBackPath = {
    getDependenciesPath: '/callback/v1.0/dependencies',
    onSubscriptionPrefix: '/callback/v1.0/tenants'
  };
  if (!credentials){
    credentials = vcapUtils.getServiceCredentials({ label: 'saas-registry' });
  }
  if (!credentials){
    return callBackPath;
  }
  try {
    if (credentials.appUrls) {
      const appUrlsJson = JSON.parse(credentials.appUrls);
      let parsedUrl = urijs.parse(appUrlsJson.getDependencies);
      callBackPath.getDependenciesPath = parsedUrl.path;
      parsedUrl = urijs.parse(appUrlsJson.onSubscription);
      let index = parsedUrl.path.indexOf('/{tenantId}');
      if (index > 0){
        parsedUrl.path = parsedUrl.path.substring(0,index);
      }
      callBackPath.onSubscriptionPrefix = parsedUrl.path;
    }
  } catch (e){
    return callBackPath;
  }
  return callBackPath;
}

function getSMSCallbackPath(credentials){
  const callBackPath = {
    getDependenciesPrefix: '/v1.0/callback/zones',
    onSubscriptionPrefix: '/v1.0/callback/zones'
  };
  if (!credentials){
    credentials = vcapUtils.getServiceCredentials({ label: 'subscription-manager' });
  }
  if (!credentials){
    return callBackPath;
  }
  try {
    const appUrlsJson = typeof credentials.app_urls === 'string' ? JSON.parse(credentials.app_urls) : credentials.app_urls;
    let parsedUrl = urijs.parse(appUrlsJson.dependenciesCallbacks.url);
    let index = parsedUrl.path.indexOf('/{zoneId}');
    if (index > 0){
      parsedUrl.path = parsedUrl.path.substring(0,index);
    }
    callBackPath.getDependenciesPrefix = parsedUrl.path;
    parsedUrl = urijs.parse(appUrlsJson.subscriptionCallbacks.url);
    index = parsedUrl.path.indexOf('/{zoneId}');
    if (index > 0){
      parsedUrl.path = parsedUrl.path.substring(0,index);
    }
    callBackPath.onSubscriptionPrefix = parsedUrl.path;
  } catch (e){
    logger.error('Failed to parse sms app_urls' + e);
    throw getError('Failed to parse sms app_urls', 500);
  }
  return callBackPath;
}

function getTenant(approuterHost){
  let tenant = null;
  if (process.env.TENANT_HOST_PATTERN){
    let tenantHostPattern = configUtils.constructRegExp(process.env.TENANT_HOST_PATTERN);
    tenant = uaaUtils.retrieveTenantFromURL(approuterHost, tenantHostPattern);
  }
  return tenant;
}
function getSaaSRegistryDependenciesBySapCloudService(sapCloudService,req, cb){
  bsUtils.getDestinationCredentialsBySapCloudService(req,sapCloudService, (err, result, relatedBusinessServicesXsappNames) => {
    if (err){
      return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService + ' ' + err);
    }
    let dependencies = [];
    if (!result){
      html5RepoUtils.attachCredentials(sapCloudService,null,null, req);
      result = html5RepoUtils.getCredentials(sapCloudService, req);
    }
    const credentials = result.credentials || result;
    if (!credentials){
      return cb(null,dependencies);
    }

    const appHostXsappname = credentials['html5-apps-repo'] && (credentials['html5-apps-repo']['xsappname'] || credentials['html5-apps-repo']['uaa']['xsappname']);
    if (appHostXsappname){
      let xsAppnames = [];
      if (appHostXsappname.indexOf(',') > -1) {
        xsAppnames = appHostXsappname.split(',');
      } else {
        xsAppnames.push(appHostXsappname);
      }
      xsAppnames.forEach((xsappname) => {
        if (xsappname !== 'undefined'){
          dependencies.push({'xsappname': xsappname});
        }
      });
    }

    const destinationXsappName = credentials['destinationXsappname'] || (credentials.destination && credentials.destination.xsappname);
    destinationXsappName && dependencies.push({'xsappname': destinationXsappName});

    if (relatedBusinessServicesXsappNames && relatedBusinessServicesXsappNames.length > 0){
      relatedBusinessServicesXsappNames.forEach((xsappname) => {
        dependencies.push({'xsappname':xsappname});
      });
    }

    for (let service in credentials) {
      if (service !== 'html5-apps-repo' && credentials[service].saasregistryenabled && credentials[service].xsappname) {
        dependencies.push({'xsappname':credentials[service].xsappname});
      }
    }

    req.loggingContext.getLogger('/Subscription');
    logger.info('Returned dependencies ' + JSON.stringify(dependencies));
    cb(null,dependencies);
  });
}

function doCheckToken(req, token, ownCredentials, cb){
  try {
    const config = {
      credentials: ownCredentials,
      correlationId: headerUtils.getCorrelationId(req)
    };
    xssec.createSecurityContext(token, config, function (err, ctx) {
      if (err) {
        cb(err, null);
      } else if (!findCallbackScope(ctx)) {
        const error = getError('Forbidden - Missing the expected scope', 403);
        cb(error, null);
      } else {
        cb(null, true);
      }
    });
  } catch (error) {
    cb (error);
  }
}
