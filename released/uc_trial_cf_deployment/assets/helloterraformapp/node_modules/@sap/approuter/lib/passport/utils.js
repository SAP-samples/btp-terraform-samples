'use strict';

const jwtDecode = require('jwt-decode');
const VError = require('verror').VError;
const headerUtil = require('../utils/header-util');
const urlUtils = require('../utils/url-utils');
const iasUtils = require('../utils/ias-utils');
const uaaUtils = require('../utils/uaa-utils');
const pathUtil = require('../utils/path-util');
const request = require('../utils/request-utils');
const loggerUtils = require('../utils/logger');
const tracer = loggerUtils.getTracer(__filename);
const urijs = require('urijs');
const configUtils = require('../utils/configuration-utils');
const vcapUtils = require('../utils/vcap-utils');
const logger = require('../utils/logger');


module.exports = {
  USER_NAME_NOT_APPLICABLE : 'n/a',
  MAX_ATTEMPTS_NUMBER: 3,
  STATE_PARAMETER_PATH:'/approuter/login/state',
  storeToken: function (req, options, done) {
    req.session.regenerate(function (err) {
      if (err) {
        return done(err);
      }

      req.session.user = module.exports.getUserProperties(options);
      req.app.tenantInfo = {
        [req.session.user.tenant] : {
          tenantid : req.session.user.tenantid
        }
      };
      req.session.save();
      done(null, req.session.user);
    });
  },

  getUserProperties: function (options) {
    const token = jwtDecode(options.accessToken);
    const userName = token.user_name || token.email;
    const userId = token.user_uuid || userName;
    let scopes = [];
    const optionsScope = options.xsuaaToken && options.xsuaaToken.scope ? options.xsuaaToken.scope : options.scope;
    if (optionsScope) {
      scopes = optionsScope.trim ? optionsScope.trim().split(' ') : optionsScope;
    }
    return {
      id: userId,
      userId: userId || this.USER_NAME_NOT_APPLICABLE,
      name: userName || this.USER_NAME_NOT_APPLICABLE, // 'n/a' is for passport
      token: {
        accessToken: options.accessToken,
        idToken: options.idToken,
        authenticationType: options.oauthOptions ? options.oauthOptions.authenticationType : 'xsuaa', // if there is no oauthOptions, it is service2approuter flow that supports only xsuaa now
        expiryDate: module.exports.getExpiresAt(options.expiresIn).getTime(),
        refreshToken: options.refreshToken,
        oauthOptions: options.oauthOptions
      },
      tenantid: token.zid || token.zone_uuid,
      scopes: scopes,
      tenant: token.ext_attr && token.ext_attr.zdn,
      urlTenant: options.urlTenant,
      xsuaaToken: options.xsuaaToken
    };
  },

  getExpiresAt: function (duration) {
    // respect network latency if possible
    let expiresIn;
    if (duration > 180) {
      expiresIn = duration - 120;
    } else {
      expiresIn = duration;
    }
    return new Date(new Date().getTime() + expiresIn * 1000);
  },

  getCallBackUrl: function (req) {
    const appRouterUrl = urlUtils.buildAppRouterUrl(req);
    const loginCallback = multipleAuthTypes(req) ? req.routerConfig.appConfig.login.callbackEndpoint + '?authType=' + pathUtil.pathAuthenticationType(req) :
      req.routerConfig.appConfig.login.callbackEndpoint;
    let proxyPrefix = '';

    if (req.headers['x-forwarded-path']) {
      let toCutOut = req.url.length;
      const parsedUrl = urijs.parse(req.url);
      if (req.headers['x-forwarded-path'].indexOf(loginCallback) > -1 && parsedUrl.query) {
        toCutOut = loginCallback.length;
      }
      const parsedXForwardedPath = urijs.parse(req.headers['x-forwarded-path']);
      proxyPrefix = parsedXForwardedPath.path.substr(0, parsedXForwardedPath.path.length - toCutOut +
        (req.url[0] === '/' ? 1 : 0));
    }
    return urlUtils.join(appRouterUrl + proxyPrefix, loginCallback);
  },

  loadOauthOptions: function (req, cb) {
    const authenticationType = pathUtil.pathAuthenticationType(req);
    module.exports.getAuthConfig(req, authenticationType, function (err, authOptions) {
      if (err) {
        return cb(err);
      }
      const url = authOptions.url;
      const zoneId = req.zoneInfo && req.zoneInfo.zoneId;
      // If route authenticationType is defined and differs from tenantLoginInfo API (zoneInfo) authenticationType,
      // prefer route authenticationType and ignore zoneInfo using existing determination logic.
      const zoneInfo = req.zoneInfo && (req.zoneInfo.authenticationType === authenticationType) && req.zoneInfo;
      const options = {
        authorizationURL: zoneInfo ? zoneInfo.authorizationEndpoint : urlUtils.join(url, authenticationType === 'ias' ? '/oauth2/authorize' : '/oauth/authorize'),
        tokenURL: zoneInfo ? zoneInfo.tokenEndpoint : urlUtils.join(authOptions.certurl || url, authenticationType === 'ias' ? '/oauth2/token' : '/oauth/token'),
        clientid: authOptions.clientid,
        clientsecret: authOptions.clientsecret,
        certificate: authOptions.certificate,
        key: authOptions.key,
        url:  url,
        callbackURL: module.exports.getCallBackUrl(req),
        customHeaders: {'x-correlationid': headerUtil.getCorrelationId(req)},
        scope: authenticationType === 'ias' ? 'openid' : null,
        authenticationType: authenticationType,
        iasZoneId: authenticationType === 'ias' ? zoneId : undefined
      };

      headerUtil.updateSapPassport(req.headers, options.customHeaders);
      cb(null, options);
    });
  },

  getAccessTokenCallback: function (strategy, req) {
    return function accessTokenCallback(err, result) {
      if (err) {
        const error = new VError(err, 'Could not obtain access token');
        error.status = err.status;
        return strategy.error(error);
      }

      function verified(err, user, info) {
        if (err) {
          return strategy.error(err);
        }
        if (!user) {
          return strategy.fail(info);
        }
        strategy.success(user, info);
      }

      try {
        strategy.verify(req, result, verified);
      } catch (ex) {
        return strategy.error(ex);
      }
    };
  },

  callUaa: function (requestOptions, shouldDoRequest, cb) {
    const requestStart = Date.now();
    let attemptsNum = module.exports.MAX_ATTEMPTS_NUMBER;
    let responseJSON;

    function doRequest() {
      if (shouldDoRequest) {
        let error = shouldDoRequest();
        if (error) {
          return cb(error);
        }

      }
      request.post(requestOptions, function onResponse(err, res, body) {
        if (err || res.statusCode !== 200) {
          tracer.info(err, 'Request attempt %d to authentication service at %s failed in %d ms.', module.exports.MAX_ATTEMPTS_NUMBER - attemptsNum + 1, requestOptions.url, Date.now() - requestStart);
          --attemptsNum;
          if (!attemptsNum) {
            if (res && res.statusCode !== 200) {
              const error = new VError('unexpected response from authentication service at %s: status code: %d, response body: "%s"',
                requestOptions.url, res.statusCode, body);
              error.status = res.statusCode;
              return cb(error);
            }
            return cb(new VError(err, 'Request to authentication service failed'));
          }
          return doRequest();
        }
        try {
          responseJSON = JSON.parse(body);
        } catch (err) {
          return cb(new VError(err, 'unexpected response from authentication service. Expected json, got: "%s"', body));
        }
        cb(null, responseJSON);
      });
    }

    doRequest();
  },

  getAuthConfig: function (req, authenticationType, cb) {
    if (authenticationType === 'ias') {
      return iasUtils.getIasConfig(req, cb);
    } else {
      return uaaUtils.getUaaConfig(req, cb);
    }
  },

  getHttpCertificates: function (certificate) {
    if (process.env.FULL_CERTIFICATE_CHAIN && process.env.FULL_CERTIFICATE_CHAIN === 'true'){
      return {
        cert:certificate
      };
    }
    let chain = certificate.split('-----BEGIN CERTIFICATE-----');
    let certsArray = [];
    for (let i = 0; i < chain.length; i++) {
      let cert = chain[i];
      if (!(cert.length !== 0)) {
        continue;
      }
      if (cert.match(/-END CERTIFICATE-/)) {
        certsArray.push('-----BEGIN CERTIFICATE-----' + cert);
      }
    }
    return {
      cert: certsArray[0] + certsArray[1]
    };
  },

  getUrlTenant: function (req) {
    let tenant = null;
    if (process.env.TENANT_HOST_PATTERN) {
      let requestHost = urlUtils.getAppRouterHost(req);
      let tenantHostPattern = configUtils.constructRegExp(process.env.TENANT_HOST_PATTERN);
      tenant = uaaUtils.retrieveTenantFromURL(requestHost, tenantHostPattern);
    }
    return tenant;
  },

  getTenantInfo: function (req) {
    const routerConfig = req.app.get('mainRouterConfig');
    const uuaOptions = routerConfig && routerConfig.uaaConfig  && routerConfig.uaaConfig.options;
    const iasOptions = routerConfig && routerConfig.iasConfig  && routerConfig.iasConfig.options;
    const isMultiTenant = !! process.env.TENANT_HOST_PATTERN;
    const  tenant = isMultiTenant ? this.getUrlTenant(req) : ((uuaOptions && uuaOptions.identityzone) || (iasOptions && iasOptions.identityzone));
    const tenantid = req.app.tenantInfo && req.app.tenantInfo[tenant] && req.app.tenantInfo[tenant].tenantid;
    return {
      multitenant : isMultiTenant,
      tenantid : tenantid || (!isMultiTenant && (uuaOptions && uuaOptions.tenantid) || (iasOptions && iasOptions.tenantid)),
      tenant: tenant
    };
  },

  sendStateParameter: async function ({method, state, req}) {
    const {application_id: guid} = vcapUtils.getAppEnv();
    const reqOptions = {
      headers: {
        'X-Cf-App-Instance': `${guid}:0`,
        'x-state-parameter-secret': req.routerConfig.stateParameterSecret
      },
      url:`https://${req.headers.host}${this.STATE_PARAMETER_PATH}`
    };
    if (method === 'post') {
      reqOptions.body = {state};
    } else {
      reqOptions.url = `${reqOptions.url}/${state}`;
    }
    const { response } = await request.axiosRequest(method, reqOptions);
    const responseMessage = response.response && response.response.data;
    if (response.statusCode === 200){
      return;
    } else if (response.statusCode === 401){
      const loggingData = logger.getAuditLogAdditionalData(req);
      const message = `${responseMessage} - Source: ${req.url}`;
      logger.writeToAuditLog(req, loggingData, message,  (err) => {
        if (err) {
          req.loggingContext.error('Error occurred when writing to audit log. Error: %s', err.message);
        }
      });
    }
    const err = new Error(responseMessage);
    err.status = response.statusCode;
    throw err;
  }
};

function multipleAuthTypes(req) {
  return req && req.routerConfig && req.routerConfig.iasConfig && req.routerConfig.iasConfig.options &&
    req.routerConfig.iasConfig.options.url && req.routerConfig.uaaConfig && req.routerConfig.uaaConfig.options &&
    req.routerConfig.uaaConfig.options.url;
}
