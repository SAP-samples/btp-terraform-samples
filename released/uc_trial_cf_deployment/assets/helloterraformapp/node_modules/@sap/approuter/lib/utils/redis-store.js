'use strict';

const zlib = require('zlib');
const Redis = require('ioredis');
const tracer = require('../utils/logger').getTracer(__filename);
const getRedisClient = require('./redis-client-driver').getClient;
Redis.Promise = global.Promise;

const APPROUTER_SESSION_PREFIX = '{approuter-sessions}';
const EXTERNAL_SESSION_PREFIX = '{external-sessions}';

const redisKey = (key, prefix = APPROUTER_SESSION_PREFIX) => `${ prefix }:${ key }`;

const compress = (data) => {
  const zip = zlib.gzipSync(Buffer.from(JSON.stringify(data)), { level: zlib.constants.Z_BEST_SPEED });
  const buff = new Buffer(zip);
  return buff.toString('base64');
};

const decompress = (base64data) => {
  if (!base64data) {
    return null;
  }
  const buff = new Buffer(base64data, 'base64');
  let zipBuff = Buffer.from(buff);
  const jsons = zlib.gunzipSync(zipBuff).toString();
  return JSON.parse(jsons);
};

const log = {
  error(msg, ...args) {
    if (tracer.isEnabled('Error')) {
      tracer.error(msg, ...args);
    }
  },
  debug(msg, ...args) {
    if (tracer.isEnabled('debug')) {
      tracer.debug(msg, ...args);
    }
  }
};

class RedisStore {
  constructor(instanceName) {
    this.instanceName = instanceName;
  }

  checkClient() {
    this.client = getRedisClient(this.instanceName);
    return !(this.client === null || this.client.closing);
  }

  async all(prefix) {
    if (this.checkClient()) {
      try {
        const keys = await this.client.keys(redisKey('*', prefix));
        log.debug(`Got keys from redis: ${ JSON.stringify(keys) }`);
        let compressedSessions = keys && keys.length > 0 && await this.client.mget(keys);
        let decompressedSessions = [];
        compressedSessions && compressedSessions.forEach((session) => {
          decompressedSessions.push(decompress(session));
        });
        return decompressedSessions;
      } catch (err) {
        log.error(`Failed to get all sessions: ${ err.message }`);
        return [];
      }
    } else {
      tracer.warning('No redis client!!');
      return [];
    }
  }

  async clear() {
    if (this.checkClient()) {
      try {
        const keys = await this.client.keys(redisKey('*'));
        log.debug(`Got keys from redis: ${ JSON.stringify(keys) }`);
        await this.client.del(keys);
      } catch (err) {
        log.error(`Failed to clear all sessions: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async destroy(sessionId) {
    if (this.checkClient()) {
      try {
        log.debug(`Destroying session with id ${ sessionId }`);
        await this.client.del(redisKey(sessionId));
      } catch (err) {
        log.error(`Failed destroying session with id ${ sessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async get(sessionId) {
    if (this.checkClient()) {
      log.debug(`Getting session with id ${ sessionId }`);
      try {
        const session = await this.client.get(redisKey(sessionId));
        return decompress(session);
      } catch (err) {
        log.error(`Failed to get session with id ${ sessionId }: ${ err.message }`);
        return null;
      }
    } else {
      tracer.warning('No redis client!!');
      return null;
    }
  }

  attachAdditionalPropertiesToSession(session, req) {
    session.req = req;
    session.reload = (cb) => cb();
    session.save = function (){};
    session.touch = function (){};
    req.session = session;
  }

  async getExternalSession(id, req, prefix) {
    if (this.checkClient()) {
      log.debug(`Getting external session with id ${ id }`);
      try {
        const session = await this.client.get(redisKey(id, (prefix || EXTERNAL_SESSION_PREFIX)));
        const decompressedSession = decompress(session);
        if (req) {
          this.attachAdditionalPropertiesToSession(decompressedSession, req);
        }
        return decompressedSession;
      } catch (err) {
        log.debug(`Failed to get external session with id ${ id }: ${ err.message }`);
        return null;
      }
    } else {
      tracer.warning('No redis client!!');
      return null;
    }
  }

  async updateExternalSession(session, prefix) {
    if (this.checkClient()) {
      try {
        log.debug(`Storing external session with id ${ session.externalSessionId }`);
        let sessionToSave = Object.assign({}, session);
        delete sessionToSave.req;
        await this.client.set(redisKey(sessionToSave.externalSessionId, (prefix || EXTERNAL_SESSION_PREFIX)), compress(sessionToSave), 'PX', (sessionToSave.externalSessionExpiration * 1000) - Date.now());
      } catch (err) {
        log.error(`Failed to set external session with id ${ session.externalSessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async destroyExternalSession(id, prefix) {
    if (this.checkClient()) {
      try {
        log.debug(`Destroying external session with id ${ id }`);
        await this.client.del(redisKey(id, (prefix || EXTERNAL_SESSION_PREFIX)));
      } catch (err) {
        log.error(`Failed destroying service-to-approuter session with id ${ id }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async length() {
    if (this.checkClient()) {
      try {
        const keys = await this.client.keys(redisKey('*'));
        log.debug(`Keys length: ${ keys.length }`);
        return keys.length;
      } catch (err) {
        log.error(`Failed to get keys length: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
      return 0;
    }
  }

  async ttl(sessionId) {
    if (this.checkClient()) {
      try {
        log.debug(`Getting session ttl with id ${ sessionId }`);
        return await this.client.ttl(redisKey(sessionId));
      } catch (err) {
        log.error(`Failed to get ttl for session with id ${ sessionId }`);
        return 0;
      }
    } else {
      tracer.warning('No redis client!!');
      return 0;
    }
  }

  async set(sessionId, session, timeout) {
    if (this.checkClient()) {
      try {
        log.debug(`Storing session with id ${ sessionId }`);
        await this.client.set(redisKey(sessionId), compress(session), 'PX', timeout * 60 * 1000);
      } catch (err) {
        log.error(`Failed to set a session with id ${ sessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }

  async exists(sessionId) {
    if (this.checkClient()) {
      try {
        log.debug(`Checking existence of session with id ${ sessionId }`);
        const exists = await this.client.exists(redisKey(sessionId));
        log.debug(`Session with id ${ sessionId } exists ? ${ !!exists }`);
        return !!exists;
      } catch (err) {
        log.error(`Failed to check if session ${ sessionId } exists: ${ err.message }`);
        return false;
      }
    } else {
      tracer.warning('No redis client!!');
      return false;
    }
  }

  async resetTimer(sessionId, timeout) {
    if (this.checkClient()) {
      try {
        log.debug(`Resetting time of session with id ${ sessionId } to ${ timeout } minutes`);
        await this.client.expire(redisKey(sessionId), timeout * 60);
      } catch (err) {
        log.error(`Failed to expire session with id ${ sessionId }: ${ err.message }`);
      }
    } else {
      tracer.warning('No redis client!!');
    }
  }
}

let store = null;

module.exports.getStore = (instanceName) => {
  if (!store) {
    store = new RedisStore(instanceName);
  }
  return store;
};
