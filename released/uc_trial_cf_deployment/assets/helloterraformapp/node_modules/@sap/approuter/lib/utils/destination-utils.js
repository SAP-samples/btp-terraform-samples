'use strict';

const _ = require('lodash');
const loggingUtils = require('./logger');
const logger = loggingUtils.getLogger('/Destination service');
const xsenv = require('@sap/xsenv');
const request = require('./request-utils');
const tokenUtils = require('./token-utils');
const headerUtils = require('./header-util');
const validator = require('validator');
const NodeCache = require('node-cache');
const logRequestInfo = require('./application-logs-utils').logRequestInfo;
const serviceInstanceDestinationsCache = new NodeCache({stdTTL: 15, checkperiod: 16});
const DESTINATION = 'destination';
const AUTH_CLIENT_CERT = 'ClientCertificateAuthentication';
const PRIVATE_LINK = 'PrivateLink';

exports.adjustDestinationProperties = adjustDestinationProperties;
exports.normalizeDestinationProperties = normalizeDestinationProperties;
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
exports.findDestination = findDestination;
exports.getDestinationsByTenant = getDestinationsByTenant;
exports.getDestinationsByDestinationKey = getDestinationsByDestinationKey;
exports.getServiceInstanceDestinationsByTenant = getServiceInstanceDestinationsByTenant;
exports.getHttpRequestOptions = getHttpRequestOptions;
exports.getDestinationCertificate = getDestinationCertificate;
exports.normalizeCertificateProperties = normalizeCertificateProperties;
exports.isDestinationCertificatesFlow = isDestinationCertificatesFlow;
exports.rejectUnauthorized = rejectUnauthorized;
exports.getDestinationCredentialsByDestinationKey = getDestinationCredentialsByDestinationKey;

function rejectUnauthorized(destination){
  const { strictSSL , trustAll , proxyType } = destination;
  return (proxyType === PRIVATE_LINK) ? !(trustAll === true) : !(strictSSL === false);
}

function isDestinationCertificatesFlow(destination) {
  const {authentication, trustStoreLocation} = destination;
  return (authentication === AUTH_CLIENT_CERT || trustStoreLocation) ? true : false;
}

function normalizeCertificateProperties(certificates) {
  if (!certificates) {
    return null;
  }
  const clonedCertificates = _.clone(certificates);
  clonedCertificates.forEach((certificate) => {
    for (const certificateKey in certificate) {
      certificate[certificateKey.toLowerCase()] = certificate[certificateKey];
      delete certificate[certificateKey];
    }
  });
  return clonedCertificates;
}

function parseTextFormat(content) {
  let ca = '';
  const pem = Buffer.from(content, 'base64').toString('ascii');
  const keySeparator = pem => pem.match(/([-]+END [^\\s]+ PRIVATE KEY[-]+)|([-]+END PRIVATE KEY[-]+)/);
  const separator = keySeparator(pem);
  if (separator) {
    const separated = pem.split(separator[0]);
    ca = separated[1];
  } else {
    ca = pem;
  }
  return ca;
}

function getHttpRequestOptions(destination, opts) {
  if (!destination.certificates) {
    return opts;
  }
  for (const certificate of destination.certificates) {
    if (certificate.trustCertificate) {
      logger.info('Sending trusted pem certificate to backend');
      opts.ca = certificate.ca;
      if (destination.proxyType === PRIVATE_LINK) {
        opts.agent.options.ca = certificate.ca;
      }
    }
    if (certificate.clientCertificate) {
      switch (certificate.type) {
      case 'p12':
        logger.info('Sending p12 certificate to backend');
        opts.pfx = certificate.buffer;
        opts.passphrase = certificate.passphrase;
        // if certificate provided by XSUUA or IAS should be deleted
        opts.cert && delete opts.cert;
        opts.key && delete opts.key;
        break;
      case 'pem':
        logger.info('Sending pem certificate to backend');
        opts.cert = certificate.cert;
        opts.key = certificate.key;
        break;
      }
    }
  }
  return opts;
}

function getDestinationCertificate(destinationConfiguration, certificates) {
  const {keyStoreLocation, keyStorePassword, trustStoreLocation, authentication} = destinationConfiguration;
  const certificatesResult = [];

  certificates.forEach((certificate) => {
    const {content, name} = certificate;
    const extension = name.split('.').pop();
    if (name === keyStoreLocation && authentication === AUTH_CLIENT_CERT) {
      if (extension !== 'p12') {
        throw new Error('unsupported certificate format');
      }
      certificatesResult.push(
        {
          clientCertificate: true,
          buffer: Buffer.from(content, 'base64'),
          passphrase: keyStorePassword,
          type: extension
        }
      );
    } else if (name === trustStoreLocation) {
      if (extension !== 'pem') {
        throw new Error('unsupported certificate format');
      }
      certificatesResult.push(
        {
          trustCertificate: true,
          ca: parseTextFormat(content),
          type: extension
        }
      );
    }
  });
  return certificatesResult.length > 0 ? certificatesResult : null;
}

function getServiceInstanceDestinationsByTenant(req, cb) {
  const getDestinationPromises = [];
  let serviceInstanceDestinations = serviceInstanceDestinationsCache.get(req.tenant);
  if (serviceInstanceDestinations) {
    return cb(null, serviceInstanceDestinations);
  }
  serviceInstanceDestinations = [];
  getDestinationInstanceCredentialsByTenant(req, function (err, tenantDestinations) {
    if (err) {
      return cb(err);
    }
    if (!tenantDestinations || tenantDestinations.length === 0) {
      return cb(null, serviceInstanceDestinations);
    }
    tenantDestinations.forEach((tenantDestination) => {
      getDestinationPromises.push(
        new Promise((resolve, reject) => {
          const destinationKey = req.tenant + '_' + tenantDestination.Name;
          getDestinationsByDestinationKey(req.app, destinationKey, headerUtils.getCorrelationId(req), false, function (err, destinations) {
            if (err) {
              reject(err);
            } else {
              resolve(destinations);
            }
          });
        })
      );
    });
    Promise.all(getDestinationPromises)
      .then((values) => {
        values.forEach(function (instanceDestinations) {
          if (instanceDestinations) {
            serviceInstanceDestinations = serviceInstanceDestinations.concat(instanceDestinations);
          }
        });
        serviceInstanceDestinationsCache.set(req.tenant, serviceInstanceDestinations);
        cb(null, serviceInstanceDestinations);
      }).catch((reason) => {
        cb(reason);
      });
  });
}

function getDestinationInstanceCredentialsByTenant(req, cb) {
  const token = req.app && req.app.services && req.app.services[DESTINATION] && req.app.services[DESTINATION].token;
  const tenantDestinations = [];
  exports.getDestinationsByTenant(headerUtils.getCorrelationId(req), null, token, req.zoneInfo, function (err, destinations) {
    if (err) {
      return cb(err);
    }
    destinations.forEach((destination) => {
      if (validator.isUUID(destination.Name, 4) && destination.tokenServiceURL &&
          req.tenant.toLowerCase() === destination.tokenServiceURL.substring(8, destination.tokenServiceURL.indexOf('.'))) {
        tenantDestinations.push(destination);
      }
    });
    cb(null, tenantDestinations);
  });
}

function getDestinationsByDestinationKey(app, destinationKey, correlationId, runtimeFlow, cb) {
  let destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
  if (!destinationToken || destinationToken.tokenRefreshTimestamp - Date.now() <= 0 || !app.services[destinationKey].credentials) {
    // eslint-disable-next-line no-unused-vars
    const [tenant, destinationId] = destinationKey.split('_');
    findDestination(destinationId, null, {app: app, correlationId: correlationId}, function (err, response) {
      if (err || !response || !response.destinationConfiguration) {
        return cb('Failed to get subaccount destination by destination key for destination key ' + destinationKey + ' ' + err);
      }
      const credentials = {
        url: response.destinationConfiguration.tokenServiceURL,
        clientid: response.destinationConfiguration.clientId,
        clientsecret: response.destinationConfiguration.clientSecret
      };
      tokenUtils.loadClientCredentialsToken(app, correlationId, credentials, destinationKey, function (err) {
        if (err) {
          let [subdomain, destinationId] = destinationKey.split('_');
          let message = 'Error while fetching client_credentials token for destination service instance '
              + destinationId + ' from subdomain ' + subdomain + ' ' + err;
          if (runtimeFlow) {
            return cb(message);
          } else { // get applications flow
            logger.error(message);
            return cb();
          }
        }
        destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
        app.services[destinationKey].credentials = response.destinationConfiguration;
        return getDestinationsByServiceInstance(destinationToken, destinationKey, cb);
      });
    });
  } else {
    return getDestinationsByServiceInstance(destinationToken, destinationKey, cb);
  }
}

function getDestinationCredentialsByDestinationKey(app, destinationKey, correlationId, cb) {
  if (!app || !app.services || !destinationKey || !app.services[destinationKey]){
    return cb('Invalid input parameters for getting destination credentials by destinationKey');
  }
  if (!app.services[destinationKey].credentials) {
    const [subdomain, destinationId] = destinationKey.split('_');
    exports.findDestination(destinationId, null, {app: app, correlationId: correlationId}, function (err, response) {
      if (err || !response || !response.destinationConfiguration) {
        return cb('Failed to get subaccount destination by destination key for destination key ' + destinationKey + ' in subdomain ' + subdomain + ' ' + err);
      }
      app.services[destinationKey].credentials = response.destinationConfiguration;
      return cb(null, app.services[destinationKey].credentials);
    });
  } else {
    return cb(null, app.services[destinationKey].credentials);
  }
}

function getDestinationsByServiceInstance(token, destinationKey, cb) {
  getDestinationsByInstanceReqOptions(token, function (err, requestOptions) {
    if (err) {
      return cb('Error while retrieving destinations for service instance ' + destinationKey + err);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        return cb('Error while retrieving destinations for service instance ' + destinationKey + ' ' + (err && err.message));
      }
      if (res.statusCode !== 200 || !res.body) {
        const errorMessage = 'Error while retrieving destinations for service instance ' + destinationKey + ' from destination service. HTTP status code: ' + res.statusCode;
        return cb(errorMessage);
      }
      try {
        const destinationLookUpResult = JSON.parse(res.body);
        destinationLookUpResult.forEach((destination) => {
          destination.destinationId = destinationKey.split('_')[1];
        });
        return cb(null, destinationLookUpResult);
      } catch (err) {
        return cb(err);
      }
    });
  });
}

function getDestinationsByInstanceReqOptions(token, cb) {
  const credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb('Destination service is not bound');
  }
  if (!token) {
    return cb('No destination token provided');
  }
  const headers = {'accept': 'application/json;charset=utf-8'};
  headers.Authorization = 'Bearer ' + token.accessToken;
  return cb(null, {
    url: credentials.uri + '/destination-configuration/v1/instanceDestinations',
    headers: headers
  });
}

function getDestinationsByTenant(correlationId, tenant, token, zoneInfo, cb) {
  getDestinationsByTenantReqOptions(correlationId, tenant, token, zoneInfo, function (error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        return cb('Error while retrieving destinations for tenant ' + tenant + ' ' + (err && err.message));
      }
      if (res.statusCode !== 200 || !res.body) {
        let errorMessage = 'Error while retrieving destinations for tenant ' + tenant + ' from destination service. HTTP status code: ' + res.statusCode;
        const error = new Error(errorMessage);
        error.status = res.statusCode;
        return cb(error);
      }
      let destinationLookUpResult;
      try {
        destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function adjustDestinationProperties(destinations) {
  destinations.forEach(function (destination) {
    if (destination.proxyType === 'OnPremise') {
      try {
        let credentials = xsenv.serviceCredentials({tag: 'connectivity'});
        destination['proxyHost'] = credentials.onpremise_proxy_host;
        destination['proxyPort'] = credentials.onpremise_proxy_port;
      } catch (error) {
        // eslint-disable-next-line no-useless-escape
        throw 'Destination \"' + destination.name +
        // eslint-disable-next-line no-useless-escape
        '\" with  ProxyType \"OnPremise\" but connectivity service is not bound.';
      }
    }
    _.defaults(destination, {
      timeout: 30000
    });
  });
}

function normalizeDestinationProperties(destinations) {
  if (!destinations) {
    return;
  }
  if (!Array.isArray(destinations)) {
    throw new Error('destinations type invalid, array is expected');
  }
  destinations.forEach(function (destination, i, destinations) {
    if (destinations[i].Authentication) { // if it destination from destinations service
      destinations[i] = normalizeDestination(destination);
      destinations[i].forwardAuthToken = destinations[i].forwardAuthToken === 'true' || destinations[i].forwardAuthToken === true;
      destinations[i].preserveHostHeader = destinations[i].preserveHostHeader === 'true' || destinations[i].preserveHostHeader === true;
      destinations[i].dynamicDestination = destinations[i].dynamicDestination === 'true' || destinations[i].dynamicDestination === true;
      destinations[i].trustAll = destinations[i].trustAll === 'true' || destinations[i].trustAll === true;
      if (destinations[i].hasOwnProperty('setXForwardedHeaders')) {
        destinations[i].setXForwardedHeaders = destinations[i].setXForwardedHeaders === 'true' || destinations[i].setXForwardedHeaders === true;
      }
      if (destinations[i].timeout && !isNaN(destinations[i].timeout)) {
        destinations[i].timeout = _.toSafeInteger(destinations[i].timeout);
      }
    }
  });
}

function getDestinationsByTenantReqOptions(correlationId, tenant, token, zoneInfo, cb) {
  let credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb('Destination service is not bound');
  }
  let destinationUrl = credentials.uri + '/destination-configuration/v1/subaccountDestinations';

  let headers = {'accept': 'application/json;charset=utf-8'};
  if (token) {
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb(null, {
      url: destinationUrl,
      headers: headers
    });
  }
  tokenUtils.getClientCredentialsTokenByTenant(correlationId, tenant, credentials, zoneInfo, function (err, token) {
    if (err) {
      return cb(err);
    }
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb(null, {
      url: destinationUrl,
      headers: headers
    });
  });
}

function getFindDestinationReqOptions(destinationName, token, options, cb) {
  let credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb('Destination service is not bound');
  }
  getDestinationToken(options, token, credentials, (err, options) => {
    if (err) {
      return cb(err);
    }
    let headers = {'accept': 'application/json;charset=utf-8'};
    let auth;
    if (options.userToken && !options.preferLocal) {
      logRequestInfo(options, 'getFindDestinationReqOptions - using destination user token to call find destination');
      auth = options.userToken;
    } else if (options && options.app && options.destinationKey && options.app.services && options.app.services[options.destinationKey] && options.app.services[options.destinationKey].token) {
      logRequestInfo(options, `getFindDestinationReqOptions - using destination key ${options.destinationKey} access token to call find destination`);
      auth = options.app.services[options.destinationKey].token.accessToken;
    } else if (options.destinationToken) {
      logRequestInfo(options, 'getFindDestinationReqOptions - using destination cc token to call find destination');
      auth = options.destinationToken;
    } else {
      return cb('Failed to determine destination token');
    }
    headers.Authorization = 'Bearer ' + auth;
    headers['x-correlationid'] = options.correlationId;
    if (options.preferLocal && options.userToken) {
      headers['x-user-token'] = options.userToken;
    }
    return cb(null, {
      url: credentials.uri + '/destination-configuration/v1/destinations/' + destinationName,
      headers: headers
    });
  });
}

function normalizeDestination(destination) {
  if (!destination) {
    return;
  }
  let keys = Object.keys(destination);
  let n = keys.length;
  let newobj = {};
  let key;
  while (n--) {
    key = keys[n];
    if (key === 'URL') {
      newobj[key.toLowerCase()] = destination[key];
    } else {
      let value = destination[key];
      key = key.replace('HTML5.', '');
      let newKey = key.substr(0, 1).toLowerCase() + key.substr(1);
      newobj[newKey] = value;
    }
  }
  return newobj;
}

function getDestinationServiceCredentials() {
  let errorOccurred;
  let credentials;
  try {
    credentials = xsenv.serviceCredentials({tag: DESTINATION});
    credentials.label = DESTINATION;
  } catch (e) {
    errorOccurred = true;
  }
  if (errorOccurred || !credentials) {
    return null;
  }
  return credentials;
}

// Finds a destination by name on all levels and returns the first match
// Search priority is destination on instance level and after that fallback to the shared destinations on subaccount level.
function findDestination(destinationName, token, options, cb) {
  if (!destinationName) {
    return cb('Cannot find destination, destination name is missing');
  }

  if (destinationName.includes('$')) {
    return cb('destination contains invalid characters, check xs-app.json route.source attribute to make sure the regex is correct');
  }

  if (destinationName.includes('*')) {
    return cb('destination contains invalid characters, make sure the DESTINATION_HOST_PATTERN regex is correct');
  }

  let errorMessage;
  let destinationLookUpResult;
  getFindDestinationReqOptions(destinationName, token, options, function (error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        return cb('Error while retrieving destination ' + destinationName + ' from destination service ' + (err && err.message) +
            ', token details: ' + (requestOptions && JSON.stringify(tokenUtils.getTokenInfo(requestOptions.headers.Authorization))));
      }
      if (res.statusCode !== 200 || !res.body) {
        errorMessage = 'Error while retrieving destination ' + destinationName + ' from destination service. HTTP status code: ' + res.statusCode +
            ', token details: ' + (requestOptions && JSON.stringify(tokenUtils.getTokenInfo(requestOptions.headers.Authorization)));
        return cb(errorMessage);
      }
      try {
        destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function getDestinationToken(options, token, credentials, cb) {

  if (token) {
    options.userToken = token;
  }

  if (options.userToken && !options.preferLocal) {
    logRequestInfo(options, 'getDestinationToken - prefer user token in case not local destination requested');
    return cb(null, options);
  }

  let tenant = options.urlTenant || (options.session && options.session.user && options.session.user.tenant);

  if ((!tenant || options.preferLocal) && options.app) {
    logRequestInfo(options, 'getDestinationToken - If no tenant, take destination client credentials token (public access or not multi-tenant approuter or SaaS Approuter APIs)');
    if (options.app.services && options.app.services[DESTINATION]
        && options.app.services[DESTINATION].token
        && options.app.services[DESTINATION].token.tokenRefreshTimestamp - Date.now() > 0) {
      options.destinationToken = options.app.services[DESTINATION].token.accessToken;
      logRequestInfo(options, 'getDestinationToken - use cached destination token');
      return cb(null, options);
    } else {
      tokenUtils.loadClientCredentialsToken(options.app, options.correlationId, credentials, DESTINATION, (err) => {
        logRequestInfo(options, 'getDestinationToken - create new cc destination token');
        if (err) {
          let message = 'Could not fetch destination token ' + err;
          return cb(message);
        }
        options.destinationToken = options.app.services[DESTINATION].token.accessToken;
        return cb(err, options);
      });
    }
  }

  // if there is a tenant and cached token is not expired, take it
  else if (tenant && options.app) {
    if (options.app.services[DESTINATION] && options.app.services[DESTINATION][tenant]
        && options.app.services[DESTINATION][tenant].token
        && options.app.services[DESTINATION][tenant].token.tokenRefreshTimestamp - Date.now() > 0) {
      options.destinationToken = options.app.services[DESTINATION][tenant].token.accessToken;
      logRequestInfo(options, 'getDestinationToken - get cached destination token by tenant');
      return cb(null, options);
    } else {
      logRequestInfo(options, 'getDestinationToken - create new destination token by tenant');
      tokenUtils.getClientCredentialsTokenByTenant(options.correlationId, tenant, credentials, (options.session && options.session.req && options.session.req.zoneInfo), (err, token) => {
        if (err) {
          let message = 'Could not get destination token from subscriber subaccount ' + tenant + ' ' + err;
          return cb(message);
        }
        if (!options.app.services[DESTINATION]) {
          options.app.services[DESTINATION] = {};
        }
        options.app.services[DESTINATION][tenant] = {token: token};
        options.destinationToken = token.accessToken;
        return cb(null, options);
      });
    }
  }
}
