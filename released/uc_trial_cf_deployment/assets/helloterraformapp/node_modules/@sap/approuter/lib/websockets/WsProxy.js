'use strict';

const http = require('http');
const cookieParser = require('cookie-parser');
const util = require('util');
const VError = require('verror').VError;
const WebSocket = require('ws');
const Session = require('express-session').Session;
const agents = require('../backend-request/agents');
const attachRouterConfig = require('../middleware/attach-router-config');
const buildProxyUri = require('../backend-request/options').buildProxyUri;
const ConnectionHandler = require('./ConnectionHandler');
const connectUtils = require('../connect/utils');
const getHeaders = require('../backend-request/headers').getHeaders;
const isAuthorized = require('../middleware/authorization-handler');
const loggerUtil = require('../utils/logger');
const loginProvider = require('../middleware/login-provider');
const pathRewriter = require('../middleware/path-rewriter');
const pathUtil = require('../utils/path-util');
const urlUtils = require('../utils/url-utils');
const whitelistUtils = require('../utils/whitelist-utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');
const destinationTokenMiddleware = require('../middleware/destination-token-middleware');
const serviceTokenMiddleware = require('../middleware/service-token-middleware');
const cacheServiceDestinations = require('../middleware/service-destinations-middleware');
const businessServiceUtils = require('../utils/business-service-utils');
const svc2Approuter = require('../middleware/service-to-approuter-middleware');
const clientCredentialsMiddleware = require('../middleware/client-credentials-token-middleware');

module.exports = WsProxy;

function WsProxy(app) {
  this._app = app;
  this._server = null;
}

WsProxy.prototype.close = function (callback) {
  if (this._server) {
    this._server.close(callback);
    this._server = undefined;
  } else {
    process.nextTick(callback);
  }
};

WsProxy.prototype.listen = function (httpServer) {
  if (this._server) {
    throw new Error('Websocket server already running!');
  }

  this._server = new WebSocket.Server({
    server: httpServer,
    verifyClient: verifyClient.bind(null, this._app)
  });
  this._server.on('connection', function serverConnection(incoming, inReq) {
    const req = inReq;
    const handler = new ConnectionHandler(req.loggingContext);
    incoming.upgradeReq = req;
    handler.onOpen(incoming, req.backendSocket);
  });
};

function verifyClient(app, info, cb) {
  const req = info.req;
  connectUtils.setPropertiesToRequest(req, app);
  req.sessionStore = app.get('memoryStore');
  req.loggingContext = loggerUtil.createRequestContext(req);
  const tracer = getTracer(req);
  tracer.debug('[websockets] incoming request url: %s', req.url);
  cacheServiceDestinations(req,{},function(err){
    if (err) {
      return reportError(err, tracer, cb);
    }
    addRouterConfig(req, function (err) {
      if (err) {
        return reportError(err, tracer, cb);
      }
      if (!req.routerConfig.appConfig.websockets.enabled) {
        return authorizationRequired(req, cb, 'websockets are disabled');
      }
      try {
        checkAllowedOrigins(req, info.origin);
        req.internalUrl = getInternalUrl(req);
      } catch (err) {
        return reportError(err, tracer, cb);
      }
      if (pathUtil.isPublicPath(req)) {
        return createBackendConnection(req, cb);
      }
      checkLoggedUser(req, function (shouldCreateConnection) {
        if (!shouldCreateConnection) {
          return cb.apply(null, arguments);
        }
        createBackendConnection(req, cb);
      });
    });
  });
}

function checkLoggedUser(req, cb) {
  const app = req.app;
  if (req.headers['x-approuter-authorization']) {
    svc2Approuter(req, null, function (err) {
      if (err) {
        return reportError(err, getTracer(req), cb);
      }
      cb(true);
    });
  } else {
    cookieParser(app.get('sessionCookieKey'))(req, null, function (err) {
      if (err) {
        return reportError(err, getTracer(req), cb);
      }
      const sessionID = req.signedCookies[app.get('cookieName')];
      if (!sessionID) {
        return authenticationRequired(req, cb);
      }
      app.get('memoryStore').get(sessionID, function (err, sess) {
        req.sessionID = sessionID;
        req.session = new Session(req, sess);
        if (loginProvider.isLoginRequired(req)) {
          return authenticationRequired(req, cb);
        }
        if (!isAuthorized(req)) {
          return authorizationRequired(req, cb);
        }
        cb(true);
      });
    });
  }
}

function reportError(err, tracer, cb) {
  if (err.status !== 403 && err.status !== 404) {
    tracer.error(err);
  } else {
    tracer.debug(err);
  }
  const status = err.status || 500;
  return cb(false, status, getErrorMessage(status, err.message, tracer));
}

function createBackendConnection(req, cb) {
  const tracer = getTracer(req);
  handleTokenExchange(req,function (err) {
    if (err) {
      return reportError(err, tracer, cb);
    }
    const targetUrl = req.internalUrl;
    const url = targetUrl.href;
    tracer.debug('[websockets] connecting to backend server: %s', url);
    let outgoing;

    try {
      const options = {
        agent: agents.get(targetUrl.protocol, buildProxyUri(targetUrl.destination)),
        headers: getHeaders(req,getServiceToken(req)),
        rejectUnauthorized: !(targetUrl.destination.strictSSL === false)
      };
      const protocols = req.headers && req.headers['sec-websocket-protocol'] ? req.headers['sec-websocket-protocol'] : null;
      outgoing = new WebSocket(url,protocols, options);
    } catch (err) {
      return reportError(new VError(err, 'Could not connect to backend server'), tracer, cb);
    }
    const errorHandler = function (err) {
      if (typeof err !== 'string' &&  err.message && err.message.startsWith('Unexpected server response')){
        try {
          err.status = parseInt(err.message.substring(err.message.indexOf(': ') + 1));
        }
        catch (error){
          err.status = undefined;
        }
      }
      const vError = new VError(err, 'Outgoing connection error occurred');
      vError.status = err.status;
      reportError(vError, tracer, cb);
    };
    outgoing.on('error', errorHandler);
    outgoing.on('open', function () {
      tracer.debug('[websockets] outgoing connection opened');
      req.backendSocket = outgoing;
      outgoing.removeListener('error', errorHandler);
      cb(true);
    });
  });
}

function checkAllowedOrigins(req, origin) {
  if (req.headers['x-approuter-authorization']){
    return;
  }
  const wsAllowedOrigins = req.routerConfig.wsAllowedOrigins || getDefaultAllowedOrigin(req);
  if (!origin || !whitelistUtils.matchWhitelist(wsAllowedOrigins, origin)) {
    const error = new Error(origin ? util.format("origin '%s' is not allowed", origin) : 'missing origin header');
    error.status = 403;
    throw error;
  }
}

function getInternalUrl(req) {
  const targetURL = pathRewriter(req);
  if (!targetURL || !targetURL.destination || !targetURL.href || targetURL.href.charAt(0) === '/') {
    const error = new Error('not able to match the web socket request to any configured backend');
    error.status = 404;
    throw error;
  }
  return targetURL;
}

function authenticationRequired(req, cb) {
  cb(false, 401, getErrorMessage(401, 'Authentication required', getTracer(req)));
}

function authorizationRequired(req, cb, message) {
  cb(false, 403, getErrorMessage(403, message || 'Not authorized', getTracer(req)));
}

function getDefaultAllowedOrigin(req) {
  const appRouterUrl = urlUtils.parse(urlUtils.buildAppRouterUrl(req));
  const wsAllowedOrigin = [{
    protocol: appRouterUrl.protocol.slice(0, -1),
    host: appRouterUrl.hostname,
    port: appRouterUrl.port
  }];
  getTracer(req).debug('[websockets] using default allowed origin:', wsAllowedOrigin);
  return wsAllowedOrigin;
}

function getTracer(req) {
  return req.loggingContext.getTracer(__filename);
}

function getErrorMessage(status, message, tracer) {
  tracer.debug('[websockets] %s', message);
  return process.env.NODE_ENV === 'development' ? message : http.STATUS_CODES[status];
}

function addRouterConfig(req,cb){
  if (dynamicRoutingUtils.isDynamicRouting()) {
    dynamicRoutingUtils.getRemoteConfiguration(req, null, function(err){
      if (err) {
        return cb(err);
      }
      if (req.dynamicRouting && req.dynamicRouting.routerConfig) {
        req.routerConfig = req.dynamicRouting.routerConfig;
        return cb();
      }
      else {
        attachRouterConfig(req, null,cb);
      }
    });
  }
  else {
    attachRouterConfig(req, null,cb);
  }
}

function handleTokenExchange(req,cb) {
  const enableConnectivityTokenExchange = process.env.ENABLE_CONNECTIVITY_TOKEN_EXCHANGE_WS
      && (process.env.ENABLE_CONNECTIVITY_TOKEN_EXCHANGE_WS === 'true' || process.env.ENABLE_CONNECTIVITY_TOKEN_EXCHANGE_WS === true);
  if (enableConnectivityTokenExchange) {
    return clientCredentialsMiddleware(req, {}, function (err) {
      if (err) {
        return cb(err);
      }
      return destinationTokenMiddleware(req, {}, function (err) {
        if (err) {
          return cb(err);
        }
        return serviceTokenMiddleware(req, {}, cb);
      });
    });
  } else {
    return destinationTokenMiddleware(req, {}, function (err) {
      if (err) {
        return cb(err);
      }
      return serviceTokenMiddleware(req, {}, cb);
    });
  }
}

function getServiceToken(req){
  const serviceTag = req.internalUrl.route.service;
  let token = null;
  if (req.session && req.session.user && req.session.user.businessServices &&
      serviceTag && req.session.user.businessServices[serviceTag]
      && businessServiceUtils.getGrantType(req.internalUrl.route.credentials) === 'user_token') {
    token = req.session.user.businessServices[serviceTag].accessToken;
  }
  return token;
}
