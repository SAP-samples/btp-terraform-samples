'use strict';

const assert = require('assert');
const Strategy = require('passport').Strategy;
const util = require('util');
const OAuth2 = require('./oauth2').OAuth2;
const passportUtils = require('./utils');
const cookieUtils = require('../utils/cookie-utils');
const headerUtil = require('../utils/header-util');
const querystring = require('querystring');
const tokenUtils = require('../utils/token-utils');
const pathUtil = require('../utils/path-util');
const loginCallbackProvider = require('../middleware/login-callback-provider');
const jwtDecode = require('jwt-decode');

module.exports = OAuth2Strategy;

function OAuth2Strategy(options, verify) {
  this.name = 'oauth2';
  assert(verify, 'OAuth2Strategy requires a "verify" callback');
  assert(options.callbackURL, 'OAuth2Strategy requires "callbackURL" option');
  assert(options.authorizationURL, 'OAuth2Strategy requires "authorizationURL" option');

  this.verify = verify;
  this._callbackURL = options.callbackURL;
  this._authorizationURL = options.authorizationURL;
  this._oauth2 = new OAuth2(options);

  Strategy.call(this, options, verify);
}

util.inherits(OAuth2Strategy, Strategy);

OAuth2Strategy.prototype.authenticate = async function (req, options) {
  options = options || {};

  if (req.query && req.query.error) {
    const error = getAuthorizationError(req.query.error_description, req.query.error);
    return (req.query.error === 'access_denied') ? this.fail(error) : this.error(error);
  }
  const loggingContext = req.loggingContext;
  const logger = loggingContext.getLogger('/Auth/OAuth2');
  const callbackURL = options.callbackURL || this._callbackURL;
  const authorizationURL = options.authorizationURL || this._authorizationURL;
  const redirectCookieName = cookieUtils.getRedirectLocationCookieName();
  const fragmentCookieName = cookieUtils.getFragmentCookieName();
  let originalUrl;
  if (!req.query || !req.query.code || (req.query.code && !loginCallbackProvider.isLoginCallback(req))) {
    let location;
    try {
      location = await this._oauth2.getCodeAuthorizationUrl(req, authorizationURL, callbackURL);
    }
    catch (error) {
      logger.error(error.message);
      return this.error(error);
    }

    logger.info('query does not exist for request url %s', req.url);

    if (process.env.PRESERVE_FRAGMENT !== 'false') {
      logger.info('sending page with client-side redirect to %s', location);
      logger.info('x-forwarded-path header: %s', req.headers['x-forwarded-path']);
      originalUrl = req.headers['x-forwarded-path'] || req.url;

      cookieUtils.signCookie(req, originalUrl, function (err, signature) {
        if (err) {
          req.res.statusCode = 500;
          req.res.statusMessage = 'Malformed server configuration';
          req.res.end();
          return;
        }
        req.res.statusCode = 200;
        req.res.setHeader('Content-Type', 'text/html');
        req.res.setHeader('Content-Security-Policy', 'script-src \'self\' \'unsafe-inline\'; frame-ancestors *');
        req.res.setHeader('Cache-Control', headerUtil.NOCACHE_HEADER_VALUE);
        let fragmentCookie = fragmentCookieName + '="+encodeURIComponent(location.hash)+";path=/";';
        let redirectCookie = redirectCookieName + '="+encodeURIComponent(location.href.split(\'#\')[0].split(location.host)[1])+";path=/";';
        let signatureCookie = signature + ';path=/";';
        let samesite = req.routerConfig && req.routerConfig.cookies && req.routerConfig.cookies.SameSite;
        req.res.end(
          '<html>' +
          '<head>' +
          '<link rel="shortcut icon" href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" />' +
          '<script>' +
          'document.cookie="' + cookieUtils.addSamesite(fragmentCookie, samesite) +
          'document.cookie="' + cookieUtils.addSamesite(redirectCookie, samesite) +
          'document.cookie="signature=' + cookieUtils.addSamesite(signatureCookie, samesite) +
          'location="' + location + '"</script>' +
          '</head>' +
          '</html>'
        );
        delete req.res;
      });
      return;
    } else {
      logger.info('sending redirect to %s', location);
      return this.redirect(location);
    }
  }
  if (req.routerConfig.stateParameterSecret) {
    try {
      await passportUtils.sendStateParameter({
        method: 'get',
        state: req.query.state,
        req
      });
    } catch (error) {
      logger.error(error.message);
      return this.error(error);
    }
  }
  const that = this;

  if (process.env.PRESERVE_FRAGMENT !== 'false') {
    let cookies = req.headers.cookie && req.headers.cookie.split(/\s*;\s*/).reduce((acc, cur) => {
      const [key, val] = cur.split('=');
      if (!acc[key]) {
        acc[key] = [];
      }
      acc[key].push(val);
      return acc;
    }, {});

    if (!cookies) {
      returnResponseStatus(req, 400, 'Cookies are missing');
      logger.error('Cookies are missing for request url %s', req.url);
      return;
    }

    const redirectCookie = querystring.unescape(cookies[redirectCookieName] && cookies[redirectCookieName][0]);
    const signatureCookie = cookies['signature'];

    cookieUtils.verifyCookie(req, redirectCookie, signatureCookie, function (err) {
      if (err) {
        returnResponseStatus(req, 400, 'Signature does not match');
        return;
      }
      delete req.res;
      getAccessToken(req, that, callbackURL, loggingContext);
    });
  } else {
    getAccessToken(req, that, callbackURL, loggingContext);
  }
};

function returnResponseStatus(req, code, message) {
  req.res.statusCode = code;
  req.res.statusMessage = message;
  req.res.end();
  delete req.res;
}

function getAuthorizationError(message, code) {
  const error = new Error(message);
  switch (code) {
  case 'access_denied':
    error.status = 403;
    break;
  case 'server_error':
    error.status = 502;
    break;
  case 'temporarily_unavailable':
    error.status = 503;
    break;
  }
  return error;
}

function getAccessToken(req, that, callbackURL, loggingContext) {
  const params = {
    'grant_type': 'authorization_code',
    'redirect_uri': callbackURL,
    code: req.query.code
  };
  const callback = passportUtils.getAccessTokenCallback(that, req);
  that._oauth2.getOAuthAccessToken(params, loggingContext, function (err, result) {
    if (err) {
      err.status = 500;
    }
    if (result) {
      result.urlTenant = req.tenant ? req.tenant : passportUtils.getUrlTenant(req);
    }
    let uaaOptions = req.extUaaConfigOptions ? req.extUaaConfigOptions : req.routerConfig.uaaConfig.options;
    if (result && pathUtil.pathAuthenticationType(req) === 'ias' && uaaOptions.url) {
      try {
        tokenUtils.exchangeToken(result.access_token, headerUtil.getCorrelationId(req), uaaOptions, function (err, xsuaaToken) {
          if (err) {
            err.status = 500;
            return callback(err);
          }
          result.xsuaaToken = jwtDecode(xsuaaToken);
          callback(err, result);
        });
      } catch (err) {
        return callback('Failed to get xsuaa credentials ' + err);
      }
    } else {
      callback(err, result);
    }
  });
}



