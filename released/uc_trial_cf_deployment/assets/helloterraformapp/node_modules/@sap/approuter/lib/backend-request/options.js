'use strict';

const http = require('http');
const https = require('https');
const agents = require('./agents');
const backendHeaders = require('./headers');
const urlUtils = require('../utils/url-utils');
const traceUtil = require('../utils/trace-util');
const stripClientCookies = require('../middleware/strip-client-cookies');
const tough = require('tough-cookie');
const passportUtils = require('../passport/utils');
const _ = require('lodash');
const destinationUtils = require('../utils/destination-utils');

exports.getLogoutRequest = function (req, accessToken, destination, xsAppDestConfig, session) {
  let method = xsAppDestConfig.logoutMethod || 'POST';
  let logoutUrl = urlUtils.join(destination.url, xsAppDestConfig.logoutPath);
  let headers = backendHeaders.getHeaders(req, accessToken, destination);
  module.exports.getBackendCookies(req,session, headers, destination);
  return getRequestImpl(method, urlUtils.parse(logoutUrl), headers, destination, null,session);
};

exports.getBackendCookies = function(req,session, headers, destination){
  if (session && session._cookieJar) {
    if (req){
      stripClientCookies(req, req.app.get('cookieName'));
    }
    let jar = _.cloneDeep(session._cookieJar); // see tough-cookie issue #59
    tough.CookieJar.deserialize(jar, function (err, cookieJar) {
      if (err) {
        return;
      }
      cookieJar.getCookieString(destination.url, function(err, cookies){
        if (err) {
          return;
        }
        if (cookies) {
          headers.cookie = headers.cookie ? headers.cookie + '; ' + cookies : cookies;
        }
      });
    });
  }
};

exports.getRequest = function (req, accessToken) {
  let headers = backendHeaders.getHeaders(req, accessToken);
  let logger = req.logger;
  return getRequestImpl(req.method, req.internalUrl, headers, req.internalUrl.destination, logger, req.session);
};

function getRequestImpl(method, parsedUrl, headers, destination, logger, session) {
  let proxyUri = exports.buildProxyUri(destination);
  let opts = {
    method: method,
    protocol: parsedUrl.protocol,
    hostname: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    agent: agents.get(parsedUrl.protocol, proxyUri, destination.proxyType === 'OnPremise'),
    rejectUnauthorized: destinationUtils.rejectUnauthorized(destination),
    headers: headers
  };
  let oauthOptions = session && session.user && session.user.token && session.user.token.oauthOptions;
  if (oauthOptions && oauthOptions.certificate) {
    let certificates = passportUtils.getHttpCertificates(oauthOptions.certificate);
    opts.cert = certificates.cert;
    opts.key  = oauthOptions.key;
  }
  if (headers.host) { // So socket does not use host header as target (allows differing host header)
    opts['servername'] = parsedUrl.hostname;
  }
  let useSSL = /^https/i.test(opts.protocol);
  if (useSSL && opts.agent.options && opts.agent.options.ca) { // fixes leaking ssl sockets in node
    opts.ca = opts.agent.options.ca;
  }
  opts = destinationUtils.getHttpRequestOptions(destination, opts);
  if (logger) {
    traceUtil.traceBackendRequest(logger, parsedUrl.href, opts);
  }
  return useSSL ? https.request.bind(undefined, opts) : http.request.bind(undefined, opts);
}

exports.buildProxyUri = function (destination) {
  let proxyHost = destination.proxyHost;
  let proxyPort = destination.proxyPort;
  if (!proxyHost) {
    return;
  }
  let hasProtocol = /^https?:\/\//i.test(proxyHost);
  if (hasProtocol) {
    return proxyHost + ':' + proxyPort;
  }
  return 'http://' + proxyHost + ':' + proxyPort;
};

