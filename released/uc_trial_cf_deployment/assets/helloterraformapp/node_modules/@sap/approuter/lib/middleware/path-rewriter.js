'use strict';

const _ = require('lodash');
const urlUtils = require('../utils/url-utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');
const businessServiceUtils = require('../utils/business-service-utils');
const configurationUtils = require('../utils/configuration-utils');
const loggerUtils = require('../utils/logger');
const tracer = loggerUtils.getTracer(__filename);
const logRequestInfo = require('../utils/application-logs-utils').logRequestInfo;
const sapIdpParam = 'sap_idp';

module.exports = function(req, matchHttpMethods /* default undefined, does not make sense for WebSockets */) {
  matchHttpMethods = !!matchHttpMethods; // Normalize to boolean

  let routerConfig = req.routerConfig;
  let routes = routerConfig.appConfig.routes;
  if (!routes) {
    return;
  }

  req.dynamicIDP = urlUtils.getQueryParam(req, sapIdpParam, false);
  let url = dynamicRoutingUtils.getCoreUrl(req);

  /*
   * Record here which HTTP methods are supported by routes that match the path.
   * If any is recorded by the end of an unsuccessful route matching, then
   * there were paths matching but supporting other HTTP methods.
   */
  let supportedHttpMethods = [];
  for (let i = 0; i < routes.length; i++) {
    let route = routes[i];
    if (!route.source.test(url)) {
      continue;
    }

    if (!matchHttpMethods || httpMethodsMatch(route.httpMethods, req.method)) {
      return applyRewriteRule(req, route, routerConfig);
    }

    supportedHttpMethods = supportedHttpMethods.concat(route.httpMethods);
  }

  if (matchHttpMethods && supportedHttpMethods.length) {
    /*
     * Remove potential duplicates in case multiple routes
     * matching by path support same HTTP method
     */
    req.supportedHttpMethods = _.uniq(supportedHttpMethods).sort();
  }
};

function httpMethodsMatch(allowedHttpMethods, requestMethod) {
  return !Array.isArray(allowedHttpMethods) || allowedHttpMethods.indexOf(requestMethod.toUpperCase()) > -1;
}

function applyRewriteRule(req, route, routerConfig) {
  let logger = req.loggingContext.getLogger('/pathRewriter');
  let logLevel = req.logger && req.logger.getLoggingLevel();
  if (logLevel === 'debug' || logLevel === 'info') {
    let logRoute = Object.assign({}, route);
    logRoute.source = logRoute.source.source.replace(/\\/g, '');
    logRequestInfo(req, `applyRewriteRule - Route ${JSON.stringify(logRoute)} used for request url ${req.url}`, tracer);
  }
  let destination = route.destination;
  const useService = route.service ? true : false;
  let path;
  let serviceDestination;
  let url = dynamicRoutingUtils.getCoreUrl (req);

  if (route.target) {
    path = url.replace(route.source, route.target);
  } else {
    path = url;
  }
  let rewrittenUrl = null;
  let credentials = null;
  if (destination) {
    let dynamicDestination = false;
    if (route.destination === '*') {
      if (!process.env['DESTINATION_HOST_PATTERN']) {
        throw new Error('Route with dynamic destination on host level matched but DESTINATION_HOST_PATTERN env. configuration missing for request url: ' + req.url);
      }
      const hostname = urlUtils.getAppRouterHost(req);
      const destinationHostPattern = configurationUtils.constructRegExp(process.env['DESTINATION_HOST_PATTERN']);
      const destinationHostPatternMatches = destinationHostPattern.exec(hostname);
      destination = destinationHostPatternMatches && destinationHostPatternMatches[1];
      if (!destination) {
        logger.info('Failed to determine destination for host level destination for request url %s - check DESTINATION_HOST_PATTERN', req.url);
        return;
      }
      dynamicDestination = true;
    } else if (destination.startsWith('$')) {
      destination = url.replace(route.source, route.destination);
      dynamicDestination = true;
    }
    const oDestination = routerConfig.destinations[destination]
        || (req && req.html5Destinations && req.html5Destinations[destination])
        || {url: 'DESTINATION_URL_PLACEHOLDER', name: destination, dynamicDestination: dynamicDestination};

    rewrittenUrl = urlUtils.parse(_.trimEnd(oDestination.url, '/') + '/' + _.trimStart(path, '/'));
    rewrittenUrl.destination = oDestination;
  } else if (useService) {
    credentials = businessServiceUtils.getCredentials(route.service, false, req);
    if (!credentials) {
      throw new Error('Failed to find credentials for service ' + route.service + ' for request url: ' + req.url);
    }
    serviceDestination = businessServiceUtils.getEndPoint(credentials, route.endpoint);
    if (!serviceDestination.url) {
      throw new Error('Failed to find endpoint ' + route.endpoint + ' for service ' + route.service + ' for request url: ' + req.url);
    }

    if (dynamicRoutingUtils.isHtml5RepoService(route.service)) {
      path = dynamicRoutingUtils.getFullPathWithoutPrefix (req, path);
    }

    rewrittenUrl = urlUtils.parse(_.trimEnd(serviceDestination.url, '/') + '/' + _.trimStart(path, '/'));
    rewrittenUrl.destination = serviceDestination;
  } else {
    rewrittenUrl = urlUtils.parse(path);
  }
  // Copy route properties instead of referring appConfig route
  // to avoid central route configuration overrides
  rewrittenUrl.route = Object.assign({}, route);
  if (req.dynamicIDP && (route.dynamicIdentityProvider || routerConfig.dynamicIdentityProvider)) {
    rewrittenUrl.route.identityProvider = req.dynamicIDP;
  }
  rewrittenUrl.route.destination = destination;
  if (useService && credentials) {
    rewrittenUrl.route.credentials = credentials;
  }
  return rewrittenUrl;
}