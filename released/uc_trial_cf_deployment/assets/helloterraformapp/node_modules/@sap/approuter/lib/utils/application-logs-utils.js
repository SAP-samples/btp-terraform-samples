/* eslint-disable camelcase */
'use strict';
const request = require('./request-utils');
const tokenUtils = require('./token-utils');
const headerUtils = require('./header-util');
const dynamicRoutingUtils = require('./dynamic-routing-utils');
const tracer = require('./logger').getTracer(__filename);
const LOG_SESSION_PREFIX = '{logSession}';

let dynLogLevelCache = null;

module.exports.logRequestError = function(req, message) {
  if (req && req.logger && process.env.SAAS_APPROUTER) {
    req.logger.error(message);
  }
};

module.exports.logRequestWarning = function(options, message, inTracer) {
  if (options && options.logger && process.env.SAAS_APPROUTER) {
    options.logger.warn(message);
  } else {
    inTracer && inTracer.warning(message);
    !inTracer && tracer.warning(message);
  }
};

module.exports.logRequestInfo = function(options, message, inTracer) {
  if (options && options.logger && process.env.SAAS_APPROUTER) {
    options.logger.info(message);
  } else {
    inTracer && inTracer.info(message);
    !inTracer && tracer.info(message);
  }
};

module.exports.setDynamicLogLevel = async function(req, level){
  let logSessionLength = process.env.LOG_SESSION_LENGTH && parseInt(process.env.LOG_SESSION_LENGTH);
  if (Number.isNaN(logSessionLength)){
    const error = new Error('LOG_SESSION_LENGTH is not a number');
    error.status = 400;
    throw error;
  }
  logSessionLength = logSessionLength === undefined ? 1800 : logSessionLength;
  if (logSessionLength === 0){
    // If log session length is zero, dynamic log level setting is disabled
    throw new Error('Dynamic log level API is currently disabled by Portal administrator');
  }
  const externalSessionStore = req && req.app && req.app.get('externalSessionStore');
  if (externalSessionStore){
    const logSession = {
      externalSessionId: req.tenant,
      externalSessionExpiration: (Math.floor(Date.now() / 1000)) + logSessionLength,
      level: level
    };
    await externalSessionStore.updateExternalSession(logSession,LOG_SESSION_PREFIX);
  }
};

module.exports.unsetDynamicLogLevel = async function(req){
  const externalSessionStore = req && req.app && req.app.get('externalSessionStore');
  if (externalSessionStore){
    await externalSessionStore.destroyExternalSession(req.tenant,LOG_SESSION_PREFIX);
  }
};

module.exports.cacheDynamicLogLevel = function(app){
  if (process.env.SAAS_APPROUTER) {
    const FIVE_MINUTES = 5 * 60 * 1000;
    setInterval(async () => {
      dynLogLevelCache = {};
      const externalSessionStore = app.get('externalSessionStore');
      if (externalSessionStore) {
        const logSessions = await externalSessionStore.all(LOG_SESSION_PREFIX);
        logSessions.forEach((logSession) => {
          dynLogLevelCache[logSession.externalSessionId] = {
            level : logSession.level
          };
        });
      }
    }, FIVE_MINUTES);
  }
};

module.exports.getDynamicLogLevel = function(req){
  return dynLogLevelCache && req.tenant && dynLogLevelCache[req.tenant] && dynLogLevelCache[req.tenant]['level'];
};

module.exports.logRequestSetTenant = function(req, tenant) {
  if (req && req.logger) {
    req.logger.setTenantId(tenant);
    if (!req.logger.getCorrelationId()) {
      req.logger.setCorrelationId(headerUtils.getCorrelationId(req));
    }
    let dynamicLogLevel = module.exports.getDynamicLogLevel(req);
    if (dynamicLogLevel){
      req.logger.setDynamicLoggingLevel(dynamicLogLevel);
    }
  }
};

module.exports.getApplicationLogs = function(req, res) {
  return new Promise((resolve, reject) => {
    tokenUtils.getAuthenticationJar(function(err, jar) {
      if (err) {
        return reject(err);
      }
      module.exports.getElasticSearchRequestOptions(req,jar,(err, requestOptions) => {
        if (err) {
          return reject(err);
        }
        module.exports.callKibanaServer(requestOptions, function(err, respBody) {
          if (err) {
            return reject(err);
          }
          const logs = [];
          if (respBody.responses) {
            respBody.responses.forEach((response) => {
              response.hits.hits.forEach((hit) => {
                if (hit._source.msg && hit._source.msg !== '-') {
                  logs.push({
                    message: hit._source.msg,
                    correlationId: hit._source.correlation_id,
                    timestamp: hit._source['@timestamp'],
                    level: hit._source.level
                  });
                }
              });
            });
          } else {
            respBody.rawResponse.hits.hits.forEach((hit) => {
              if (hit._source.msg && hit._source.msg !== '-') {
                logs.push({
                  message: hit._source.msg,
                  correlationId: hit._source.correlation_id,
                  timestamp: hit._source['@timestamp'],
                  level: hit._source.level
                });
              }
            });
          }
          res.setHeader('Content-Type', 'application/json');
          res.end(JSON.stringify(logs));
        });
      });
    });
  });
};

module.exports.callKibanaServer = function(requestOptions, cb) {
  request.post(requestOptions, function(err, response, body) {
    if (err || response.statusCode !== 200) {
      const error = new Error('Failed to execute query ' + requestOptions.body + ' response status ' +
          response.statusCode + ' ' + (body ? body : '') + err);
      return cb(error);
    }
    const respBody = JSON.parse(response.body);
    cb(null, respBody);
  });
};

function kibanaQuery(req, isNew) {
  const timeRange = 1440; // One day in minutes
  const timestampNow = new Date();
  const end = timestampNow.getTime();
  const start = end - timeRange * 60 * 1000;
  const timestampYesterday = new Date(timestampNow);
  const logLevel = module.exports.getDynamicLogLevel(req) || 'ERROR';
  timestampYesterday.setHours(timestampYesterday.getHours() - 24);
  if (req.headers['x-application-key']){
    let applicationKey = dynamicRoutingUtils.getApplicationKey({url: '/' + req.headers['x-application-key']});
    let tenantKey = applicationKey && applicationKey.appDestinationId ? req.tenant + '-' + applicationKey.appDestinationId + '.' + applicationKey.appPrefix + '.' + applicationKey.appNameWithoutPrefix :
      req.tenant + '-' + applicationKey.appPrefix + '.' + applicationKey.appNameWithoutPrefix;
    return isNew ? kibanaDayQueryNew(timestampNow, start, end, tenantKey, logLevel) : kibanaDayQuery(timestampNow, start, end, tenantKey, logLevel);
  } else {
    return isNew ? kibanaDayQueryNew(timestampNow, start, end, req.tenant, logLevel) : kibanaDayQuery(timestampNow, start, end, req.tenant, logLevel);
  }
}

module.exports.getElasticSearchRequestOptions = function(req,jar,cb){
  let logger = req.logger;
  let requestOptions = {
    url: process.env.LOGS_URL + '/api/status',
    jar: jar,
    headers: {
      'kbn-xsrf': 'true',
      'Content-Type': 'application/json'
    }
  };
  // Get Kibana server version
  request.get(requestOptions, function(err, response, apiStatusBody) {
    if (err || response.statusCode !== 200) {
      const error = new Error('Failed to get Kibana api status ' + ' response status ' +
          response.statusCode + (err || ''));
      return cb(error);
    }
    let jsonBody = null;
    try {
      jsonBody = JSON.parse(apiStatusBody);
    } catch (e) {
      return cb(new Error('Failed to parse get api status response ' + e));
    }
    logger && logger.info('Elastic search version is: ' + jsonBody.version.number);

    if (jsonBody.version.number === '7.4.2')
    {
      requestOptions.url = process.env.LOGS_URL + '/elasticsearch/_msearch';
      requestOptions.headers['Content-Type'] = 'application/x-ndjson';
      requestOptions.body = kibanaQuery(req);
    } else { // Newer versions
      requestOptions.url =  process.env.LOGS_URL + '/internal/search/es';
      requestOptions.body = kibanaQuery(req, true);
    }
    cb(null,requestOptions);
  });
};

function kibanaDayQuery(timestampReferenceDay, startTime, endTime, tenant, logLevel) {
  const todayString = timestampReferenceDay.toISOString().substring(0, 10);
  const kibanaQuery0 = {
    'index': ['logstash-2016.07.01-es5'],
    'ignore_unavailable': true
  };
  kibanaQuery0.index = 'logstash-' + todayString.replace(/-/g, '.');

  const kibanaQuery1 = { // AppELK template
    'size': 10000,
    '_source': ['msg', '@timestamp', 'level', 'correlation_id'],
    'query': {
      'bool': {
        'must': [{
          'range': {
            '@timestamp': {
              'format': 'epoch_millis',
              'gte': startTime,
              'lte': endTime
            }
          }
        }, {
          'match': {
            'tenant_id': tenant
          }
        }
        ]
      }
    }
  };
  if (logLevel === 'ERROR') {
    kibanaQuery1.query.bool.must.push({
      'match': {
        'level': logLevel
      }
    });
  }
  return JSON.stringify(kibanaQuery0) + '\n' + JSON.stringify(kibanaQuery1) + '\n';
}

function kibanaDayQueryNew(timestampReferenceDay, startTime, endTime, tenant, logLevel) {
  const query = {
    'params': {
      'index': 'logstash-*',
      'body': {
        'size': 10000,
        '_source': ['msg', '@timestamp', 'level', 'correlation_id'],
        'query': {
          'bool': {
            'must': [{
              'range': {
                '@timestamp': {
                  'format': 'epoch_millis',
                  'gte': startTime,
                  'lte': endTime
                }
              }
            }, {
              'match': {
                'tenant_id': tenant
              }
            }
            ]
          }
        }
      }
    }
  };
  if (logLevel === 'ERROR'){
    query.params.body.query.bool.must.push({
      'match': {
        'level': logLevel
      }
    });
  }
  return JSON.stringify(query);
}