'use strict';

const request = require('./request-utils');
const vcapUtils = require('./vcap-utils');
const tokenUtils = require('./token-utils');
const headerUtils = require('./header-util');
const destinationUtils = require('./destination-utils');

exports.addSubscribedApplications = addSubscribedApplications;
exports.fetchSubscribedApplications = fetchSubscribedApplications;

function addSubscribedApplications(req, html5AppsResponse, cb) {
  if (!process.env.RETURN_SUBSCRIBED_APPLICATIONS) {
    return cb(null, html5AppsResponse);
  }
  let tracer = req.loggingContext.getTracer(__filename);
  let tenant = req.tenant;
  let html5RepoCredentials = vcapUtils.getServiceCredentials({tag: 'html5-apps-repo-rt'});
  html5RepoCredentials.label = 'html5-apps-repo-rt';
  tokenUtils.getClientCredentialsTokenByTenant(headerUtils.getCorrelationId(req), tenant, html5RepoCredentials, null, (err, token) => {
    if (err) {
      tracer.error('Failed to get html5-repo token by tenant ' + err + ' check if html5-apps-repo app-runtime is subscribed to tenant: ' + tenant);
      return cb(null, html5AppsResponse);
    }
    exports.fetchSubscribedApplications(tenant, token, html5RepoCredentials, tracer, (err, subscribedApplications) => {
      if (err || !subscribedApplications) {
        return cb(err, html5AppsResponse);
      }
      let subdomains = {};
      let tenantDestinationsPromises = [];
      let appHostDestMap = {};
      subscribedApplications.forEach((subscribedApplication) => {
        if (!subdomains[subscribedApplication.subdomain]) {
          subdomains[subscribedApplication.subdomain] = null;
          tenantDestinationsPromises.push(
            new Promise((resolve, reject) => {
              let reqCopy = {
                tenant: subscribedApplication.subdomain,
                app: req.app
              };
              destinationUtils.getServiceInstanceDestinationsByTenant(reqCopy, (err, instanceDestinations) => {
                if (err) {
                  return reject(err);
                }
                instanceDestinations.forEach((destination) => {
                  if (destination.app_host_id) {
                    appHostDestMap[destination.app_host_id] = destination.destinationId;
                  }
                });
                resolve();
              });
            })
          );
        }
      });

      Promise.all(tenantDestinationsPromises)
        .then(() => {
          subscribedApplications.forEach((subscribedApplication) => {
            let application = subscribedApplication;
            application.destinationId = appHostDestMap[subscribedApplication.appHostId];
            let host = req.HTML5AppHost.indexOf('https://') !== 0 ? 'https://' + req.HTML5AppHost : req.HTML5AppHost;
            application['url'] = host + '/' + (application.destinationId ? application.destinationId + '.' : '')
                  + application.sapCloudService.replace(/\./g, '') + '.' + application.applicationName + '-' + application.applicationVersion;
            html5AppsResponse.applications.push(application);
          });
          cb(null, html5AppsResponse);
        })
        .catch((err) => {
          cb('Failed to merge subscribed applications ' + err);
        });
    });
  });
}

function fetchSubscribedApplications(tenant, token, html5RepoCredentials, tracer, cb) {
  let requestOptions = {
    url: html5RepoCredentials.uri + '/applications/subscriptions',
    headers: {
      Authorization: 'Bearer ' + token.accessToken
    }
  };
  request.get(requestOptions, function onResponse(err, res, body) {
    if (err) {
      return cb('Failed to get subscribed applications by tenant ' + tenant + ' ' + err);
    }
    if (res.statusCode !== 200) {
      tracer.error('Failed to get subscribed applications by tenant ' + tenant + ' status: ' + res.statusCode);
      return cb(null, null);
    }
    cb(null, JSON.parse(body));
  });
}