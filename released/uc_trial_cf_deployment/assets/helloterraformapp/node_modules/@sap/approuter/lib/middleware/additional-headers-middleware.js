'use strict';

const _ = require('lodash');
// eslint-disable-next-line no-undef
const tracer = require('../utils/logger').getTracer(__filename);

const X_FRAME_OPTIONS = 'x-frame-options';

module.exports = function additionalHeaders(req, res, next) {
  let routerConfig = req.routerConfig;

  let additionalHeaders = routerConfig.additionalHeaders.slice();

  additionalHeaders = modifyAdditionalHeadersFromResponseHeaders(req,additionalHeaders);

  if (routerConfig.sendXFrameOptions) {
    let xFrameHeader = _.find(additionalHeaders, function searchXFrame(header) { return !!header[X_FRAME_OPTIONS]; });
    if (!xFrameHeader) {
      res.setHeader(X_FRAME_OPTIONS, 'SAMEORIGIN');
    }
  }
  additionalHeaders.forEach(function addAdditionalHeader(header) {
    _.forEach(header, function setHeader(value, name) {
      // http://tools.ietf.org/html/rfc7230#section-3.2.2
      // If the value of a header is an array, then it is serialized as comma separated list.
      let currentValue = res.getHeader(name);
      if (currentValue === undefined) {
        res.setHeader(name, value);
      } else if (Array.isArray(currentValue)) {
        currentValue.push(value);
      } else { // string
        res.setHeader(name, [currentValue, value]);
      }
    });
  });

  next();
};

function modifyAdditionalHeadersFromResponseHeaders(req, additionalHeaders) {
  let foundIndex;

  if (!req.routerConfig.appConfig.responseHeaders){
    return additionalHeaders;
  }

  req.routerConfig.appConfig.responseHeaders.forEach(function (responseHeader) {
    foundIndex = -1;

    for (let i = 0; i < additionalHeaders.length; i++) {
      if (additionalHeaders[i].hasOwnProperty(responseHeader.name)) {
        foundIndex = i;
        break;
      }
    }

    if (foundIndex > -1) {
      additionalHeaders[foundIndex] = {
        [responseHeader.name]: responseHeader.value
      };
      tracer.debug('found response header name %s in additional headers, so update response header value %s instead of previous value', responseHeader.name, responseHeader.value);
    }
    else {
      additionalHeaders.push({
        [responseHeader.name]: responseHeader.value
      });
    }

  });

  return additionalHeaders;
}