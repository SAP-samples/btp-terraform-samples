'use strict';
const _ = require('lodash');
const axios  = require('axios');
const { wrapper }  = require('axios-cookiejar-support');
const querystring = require('querystring');
const https = require('https');

// support cookiejar
wrapper(axios);
axios.defaults.withCredentials = true;

// convert request options to 'axios' format
const axiosRequestOptions = (method , request) => {
  const clonedRequestOpt = _.clone(request);
  clonedRequestOpt.method = method;
  clonedRequestOpt.transformResponse = function (res){   // prevent JSON.parse
    return res;
  };
  if (clonedRequestOpt.cert && clonedRequestOpt.key){
    clonedRequestOpt.httpsAgent = new https.Agent({
      cert:clonedRequestOpt.cert,
      key:clonedRequestOpt.key
    });
    delete clonedRequestOpt.cert;
    delete clonedRequestOpt.key;
  }
  if (clonedRequestOpt.form){
    if (!clonedRequestOpt.headers){
      clonedRequestOpt.headers = {};
    }
    clonedRequestOpt.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    clonedRequestOpt.data = querystring.stringify(clonedRequestOpt.form);
    delete clonedRequestOpt.form;
  }
  if (clonedRequestOpt.auth) {
    clonedRequestOpt.auth.username = clonedRequestOpt.auth.user;
    clonedRequestOpt.auth.password = clonedRequestOpt.auth.pass;
    delete clonedRequestOpt.auth.user;
    delete  clonedRequestOpt.auth.pass;
  }
  if (clonedRequestOpt.body){
    clonedRequestOpt.data = clonedRequestOpt.body;
    delete clonedRequestOpt.body;
  }
  if (clonedRequestOpt.followRedirect === false){
    clonedRequestOpt.maxRedirects = 0 ;  // prevent redirect
    clonedRequestOpt.validateStatus = function (status) {
      return status >= 200 && status < 303; //  prevent Promise.reject when status code 302
    };
    delete clonedRequestOpt.followRedirect;
  }
  return clonedRequestOpt;
};

const get = (requestOptions, callback) => {
  (async () => {
    const {error , response , body} = await axiosRequest('get',requestOptions);
    return callback(error ,response , body);
  })();
};

const post = (requestOptions,callback) => {
  (async () => {
    const {error , response , body} = await axiosRequest('post',requestOptions);
    return callback(error ,response , body);
  })();
};

const pipe = async (requestOptions , response) => {
  requestOptions.responseType = 'stream';
  const resp = await axiosRequest('get',requestOptions);
  resp.body.pipe(response);
};

const axiosRequest = async (method, requestOptions) => {
  let error = null;
  const options = axiosRequestOptions(method,requestOptions);
  const response = await axios(options).catch(err => error = err);
  if (response){
    response.statusCode = response.status;
    response.body = response.data;
    if (!response.statusCode){
      const statusCode = error && error.response && error.response.status;
      response.statusCode = statusCode;
    }
  }
  return {
    error : (error && error.response) ? null : error,
    response,
    body : response ? response.data : null,
  };
};

module.exports = {
  post,
  get,
  pipe,
  axiosRequestOptions,
  axiosRequest
};