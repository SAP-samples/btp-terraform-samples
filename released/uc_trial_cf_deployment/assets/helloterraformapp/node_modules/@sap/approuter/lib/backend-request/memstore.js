'use strict';


/*
 * express-session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

const session = require('express-session');
const util = require('util');
const tracer = require('../utils/logger').getTracer(__filename);
/**
 * Shim setImmediate for node.js < 0.10
 * @private
 */

/**
 * A session store in memory.

 * @param {Object} [options]
 * @param {Number} [options.timeout] Session timeout (in minutes). Number has to be positive.
 * @public
 */

let Store = session.Store;

function MemoryStore(options) {
  Store.call(this);
  options = options || {};
  this.store = options.externalSessionStore;
  this.options = {};
  this.sessions = {};
  this.sessionTimers = {};
  if (options.timeout && options.timeout < 1) {
    options.timeout = null;
  }

  this.options.timeout = (options.timeout || 15) * 6;

  let getSessionFn = getSession.bind(this);
  let self = this;
  this.sessionChecker = setInterval(function () {
    for (let sessionId in self.sessionTimers) {
      if (--self.sessionTimers[sessionId] <= 0) {
        getSessionFn(sessionId, (sessionObject, err) => {
          if (!err && sessionObject) {
            self.emit('timeout', sessionObject);
            self.destroy(sessionId);
          }
        });
      }
    }
  },
  10 * 1000); // runs every 10 seconds
  return this;
}

/**
 * Inherit from Store.
 *
 */

util.inherits(MemoryStore, Store);

/**
 * Get all active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.all = function all(callback) {
  let sessions = {};
  Object.entries(this.sessions).forEach(([ sessionId, session ]) => {
    const sessionObject = JSON.parse(session);
    sessionObject.id = sessionId;
    sessions[sessionId] = JSON.stringify(sessionObject);
  });
  callback && callback(null, sessions);
};

/**
 * Clear all sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.clear = function clear(callback) {
  this.store && this.store.clear();
  this.sessions = {};
  this.sessionTimers = {};
  callback && callback();
};

/**
 * Destroy the session associated with the given session ID.
 *
 * @param {string} sessionId
 * @public
 */

MemoryStore.prototype.destroy = function destroy(sessionId, callback) {
  this.store && this.store.destroy(sessionId);

  if (!this.sessions[sessionId]) {
    return callback && callback();
  }

  let session = this.sessions[sessionId];
  delete this.sessionTimers[sessionId];
  delete this.sessions[sessionId];
  this.emit('destroy', JSON.parse(session));
  callback && callback();
};

/**
 * Fetch session by the given session ID. Never returns error.
 *
 * @param {string} sessionId
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.get = function get(sessionId, callback) {
  getSessionResetTimeout.call(this, sessionId, session => callback(null, session));
};

/**
 * Commit the given session associated with the given sessionId to the store.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

/**
 * Get number of active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.length = function length(callback) {
  callback(null, Object.keys(this.sessions).length);
};

MemoryStore.prototype.set = function set(sessionId, session, callback) {
  storeSession.call(this, sessionId, session);
  resetTimer.call(this, sessionId);
  callback && callback();
};

/**
 * Touch the given session object associated with the given session ID.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.touch = function touch(sessionId, session, callback) {
  getSessionResetTimeout.call(this, sessionId, currentSession => {
    if (currentSession) {
      // update expiration
      currentSession.cookie = session.cookie;
      storeSession.call(this, sessionId, currentSession);
    }
    callback && callback();
  });
};

/**
 * Reset timer for session
 *
 * @param {string} sessionId
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.resetSessionTimer = function (sessionId, callback) {
  let error = null;
  if (this.sessionTimers[sessionId]) {
    resetTimer.call(this, sessionId);
  } else {
    error = new Error('Could not reset session timer! Session ' + sessionId + ' missing!');
  }
  return callback && callback(error);
};


/**
 * Get session timeout
 * @returns {Number} Default session timeout in minutes
 * @public
 */

MemoryStore.prototype.getDefaultSessionTimeout = function () {
  return this.options.timeout / 6;
};

/**
 * Get specific session timer
 * @param sessionId
 * @param callback callback(err, time), time is in minutes
 * @public
 */

MemoryStore.prototype.getSessionTimeout = function (sessionId, callback) {
  let timer = this.sessionTimers[sessionId];
  callback(timer ? null : new Error('Invalid session'), timer && timer / 6);
};

/**
 * Updates the session in the memstore by applying function change to it without changing the session timer.
 *
 * @param {string} sessionId
 * @param {function} change A function that changes the session - function change(session)
 * @param {boolean} resetTimer defaults to true
 */
MemoryStore.prototype.update = function (sessionId, change, shouldResetTimer) {
  getSession.call(this, sessionId, (session, err) => {
    if (err && tracer.isEnabled('Error')) {
      tracer.error('Failed to get session with sessionId %s', sessionId);
    }
    if (!session) {
      return change(null);
    }
    change(session);
    storeSession.call(this, sessionId, session);
    if (shouldResetTimer !== false) {
      resetTimer.call(this, sessionId);
    }
  });
};

/**
 * Get session from the store and reset timeout.
 * @param {string} sessionId
 * @param callback
 * @returns {object} session
 * @private
 */
function getSessionResetTimeout(sessionId, callback) {
  getSession.call(this, sessionId, (session, err) => {
    if (err && tracer.isEnabled('Error')) {
      tracer.error('Failed to get session with sessionId %s', sessionId);
    }
    if (session && !session.externalSessionId) {
      resetTimer.call(this, sessionId);
    }
    callback(session);
  });
}

/**
 * Gets the session from the remote store
 * @param sessionId
 */
async function getSessionFromRemoteStore(sessionId) {
  const session = await this.store.get(sessionId);
  if (session) {
    const sessionObject = JSON.parse(session);
    sessionObject.id = sessionId;
    return sessionObject;
  }
}

/**
 * Get session from the store.
 * @param {string} sessionId
 * @param callback
 * @returns {object} session
 * @private
 */
function getSession(sessionId, callback) {
  const sessionJson = this.sessions[sessionId];
  if (sessionJson) {
    const session = JSON.parse(sessionJson);
    Object.defineProperty(session, 'id', { value: sessionId });
    callback(session);
  } else if (this.store) {
    getSessionFromRemoteStore.call(this, sessionId).then(callback);
  } else {
    callback();
  }
}

async function resetTimerRemoteStore(sessionId) {
  const exists = await this.store.exists(sessionId);
  if (exists) {
    await this.store.resetTimer(sessionId, this.options.timeout / 6);
  }
}

/**
 * Reset timer for session
 * @param {string} sessionId
 * @private
 */
function resetTimer(sessionId) {
  if (this.store) {
    resetTimerRemoteStore.call(this, sessionId);
  }
  let isUpdate = this.sessionTimers.hasOwnProperty(sessionId);
  this.sessionTimers[sessionId] = this.options.timeout;
  if (isUpdate) {
    this.emit('update', sessionId, this.options.timeout / 6); // in minutes
  }
}

function storeSession(sessionId, session) {
  const stringSession = JSON.stringify(session, function (key, value) {
    return (key === 'id') ? undefined : value; // skip id
  });

  this.store && this.store.set(sessionId, stringSession, this.options.timeout / 6);

  let isUpdate = this.sessions.hasOwnProperty(sessionId);
  this.sessions[sessionId] = stringSession;
  if (isUpdate) {
    this.emit('update', sessionId);
  }
}

module.exports = MemoryStore;
